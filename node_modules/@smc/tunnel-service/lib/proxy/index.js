
// var httpProxy = require('http-proxy');
// var http = require('http');
var bouncy = require('bouncy'); // bouncy takes the bugs away

var Promise = require('bluebird');
var util = require('util');

module.exports = ProxyService;

function ProxyService() {
  this.__routes = {};
  this.__websockets = {};
  // this.__proxy = null;
  // this.__gateway = null;
};

/**
 * Create new hostname route to tunnel entrance
 * 
 * @api public
 * @param {Tunnel} tunnel
 *
 * Provide tunnel instance as emitted in 'tunnel/open' by the websocket-tunnel component.
 * Creates a "route" to proxy by hostname <tunnelId>.any.domain.name into the tunnel entrance.
 *
 */

ProxyService.prototype.createRoute = function($happn, tunnel) {

  if (!tunnel.forwarding) {
    // tunnel is not open, no address to route to
    return;
  }

  var hostref = tunnel.id.toLowerCase();

  var route = {
    hostref: hostref,
    tunnel: {
      id: tunnel.id,
      serverId: tunnel.serverId,
    },
    forwarding: tunnel.forwarding.address + ':' + tunnel.forwarding.port
  }

  this.__routes[hostref] = route;

  $happn.log.$$TRACE('route/create', route);

  $happn.emit('route/create', route);

  $happn.log.info('route hostref \'%s\' to \'%s\'', route.hostref, route.forwarding)

};

/**
 * Destroy a route
 *
 * @api public
 * @param {Tunnel} tunnel
 *
 */

ProxyService.prototype.destroyRoute = function($happn, tunnel) {
  
  var hostref = tunnel.id.toLowerCase();
  var route = this.__routes[hostref];

  delete this.__routes[hostref];

  $happn.log.$$TRACE('route/destroy', route);

  $happn.emit('route/destroy', route);

};

/**
 * List the routes in the proxy
 *
 * @api public
 * 
 */

ProxyService.prototype.getRoutes = function($happn) {
  return this.__routes;
};


/**
 * Initialize (use as startMethod)
 *
 * @api public
 * @param {{listenPort: Number, tunnelComponentName: String}} opts
 * @param {Function} callback
 *
 */

ProxyService.prototype.initialize = function($happn, opts, callback){
  var _this = this;

  opts = opts || { listenPort: 80 }
  opts.listenPort = opts.listenPort || 80;

  $happn.log.$$TRACE('intialize', opts);

  var server = bouncy(function(req, res, bounce) {

    var target

    try {
      target = _this.__target($happn, req);
      bounce(target);
    }

    catch (e) {
      $happn.log.$$DEBUG('missing route for url %s', req.url, e);
      // $happn.emit('route/error', {
      //   error: e, 
      //   url: req.url,
      //   // url: require('url').parse(req.url,true),
      // });
      res.statusCode = 404;
      res.statusMessage = 'missing route for url';
      res.end();
    }

  });

  server.on('error', function(e) {
    $happn.log.error('proxy error', e);
  });



  // var proxy = this.__proxy = new httpProxy.createProxyServer({ws: true});
  // var gateway = this.__gateway = http.createServer(function (req, res) {
  //   try{
  //     proxy.web(req, res, {target: _this.__target($happn, req)});
  //   } catch(e){
  //     $happn.emit('route/error-web', {
  //       error: e, 
  //       url: req.url
  //     });
  //     res.statusCode = 404;
  //     res.statusMessage = 'missing route for url';
  //     res.end();
  //   }
  // });

  // gateway.on('upgrade', function (req, socket, head) {
  //   try{
  //     proxy.ws(req, socket, head, {target: _this.__target($happn, req, socket)});
  //   }catch(e){
  //     try {
  //       $happn.emit('route/error-websocket', {
  //         error: e,
  //         url: req.url
  //       });
  //       socket.close();
  //     } catch (e) {}
  //   }
  // });

  // proxy.on('error', function(e) {
  //   $happn.log.error('proxy error', e);
  // });

  // gateway.on('error', function(e) {
  //   $happn.log.error('gateway error', e);
  // });


  if (opts.tunnelComponentName && !opts.tunnelEndpointName) {

    var tunnelEvents = $happn.event[opts.tunnelComponentName];

    tunnelEvents.on('tunnel/open', function(tunnel){
      _this.createRoute($happn, tunnel);
    });

    tunnelEvents.on('tunnel/destroy', function(tunnel){
      _this.destroyRoute($happn, tunnel);
    });

    tunnelEvents.on('tunnel/close', function(tunnel){
      _this.destroyRoute($happn, tunnel);
    });

    // There may already be tunnels present by the time this proxy comes online,
    // get the list.

    $happn.exchange[opts.tunnelComponentName].listServers()

    .then(function(servers) {
      return Promise.map(servers, function(server) {
        return $happn.exchange[opts.tunnelComponentName].listTunnels(server)
      });
    })

    .then(function(arrayarray) {
      arrayarray.forEach(function(array) {
        array.forEach(function(tunnel) {
          // createRoute checks that the tunnel is 'open'
          _this.createRoute($happn, tunnel);
        });
      });
    });

  }

  if (opts.tunnelComponentName && opts.tunnelEndpointName) {

    var tunnelEvents = $happn.event[opts.tunnelEndpointName][opts.tunnelComponentName];

    tunnelEvents.on('tunnel/open', function(tunnel){
      _this.createRoute($happn, tunnel);
    });

    tunnelEvents.on('tunnel/destroy', function(tunnel){
      _this.destroyRoute($happn, tunnel);
    });

    tunnelEvents.on('tunnel/close', function(tunnel){
      _this.destroyRoute($happn, tunnel);
    });

    // There may already be tunnels present by the time this proxy comes online,
    // get the list.

    $happn.exchange[opts.tunnelEndpointName][opts.tunnelComponentName].listServers()

    .then(function(servers) {
      return Promise.map(servers, function(server) {
        return $happn.exchange[opts.tunnelEndpointName][opts.tunnelComponentName].listTunnels(server)
      });
    })

    .then(function(arrayarray) {
      arrayarray.forEach(function(array) {
        array.forEach(function(tunnel) {
          // createRoute checks that the tunnel is 'open'
          _this.createRoute($happn, tunnel);
        });
      });
    });

  }

  // gateway.listen(opts.listenPort, callback);

  server.listen(opts.listenPort, callback);

}

ProxyService.prototype.__target = function($happn, req, socket){

  var hostref = req.headers.host.split('.')[0];
  var route = this.__routes[hostref];

  if (!route) throw new Error('no route for ' + hostref);

  var target = util.format('%s://%s', req.protocol || 'http', route.forwarding);

  // directly to leaf without tunnel
  // var target = util.format('%s://%s', req.protocol || 'http', 'localhost:11011');

  return target;

}


