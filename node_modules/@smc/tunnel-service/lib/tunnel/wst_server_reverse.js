//###############################################################################
//##
//# Copyright (C) 2014-2015 Andrea Rocco Lotronto
//##
//# Licensed under the Apache License, Version 2.0 (the "License");
//# you may not use this file except in compliance with the License.
//# You may obtain a copy of the License at
//##
//# http://www.apache.org/licenses/LICENSE-2.0
//##
//# Unless required by applicable law or agreed to in writing, software
//# distributed under the License is distributed on an "AS IS" BASIS,
//# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//# See the License for the specific language governing permissions and
//# limitations under the License.
//##
//###############################################################################
  
var WebSocketServer, bindSockets, http, net, url, ServerReverse, util, EventEmitter;

WebSocketServer = require('websocket').server;
http = require('http');
url = require("url");
net = require("net");
bindSockets = require("./bindSockets_reverse");
util = require('util');
EventEmitter = require('events').EventEmitter;



var gotCarrier = new EventEmitter();

ServerReverse = function(log) {

  this.log = log;
  
  this.httpServer = http.createServer(function(request, response) {
    log.warn('received unhandled request for url %s', request.url);
    response.writeHead(404);
    return response.end();
  });
      
  this.wsServer = new WebSocketServer({
    httpServer: this.httpServer,
    autoAcceptConnections: false
  });
}

util.inherits(ServerReverse, EventEmitter);

ServerReverse.prototype.start = function(opts, callback) {

  var _this = this;
  var wsport = opts.wsport;
  var wshostname = opts.wshostname;
  
  this.defaultForwardingHostname = opts.forwardingHostname || '0.0.0.0';
  this.startOpen = opts.startOpen;

  this.carrierWait = opts.carrierWait || 10000;
  this.awaitingCarrier = {};

  this.httpServer.listen(wsport, wshostname, function(e) {
                                                 //
                                                // i'm not sure that this e exists
    var address = _this.httpServer.address();
    _this.url = util.format('http://%s:%d',  address.address, address.port);
    _this.log.info('server listening %s', _this.url);
    if (typeof callback == 'function') callback(e, _this.url);
  });
  
  this.wsServer.on('request', function(request) {

    // TODO: handle reconnect

    var uri = url.parse(request.httpRequest.url, true);
    var tunnelId = uri.query.id;
    
    if (uri.query.init == undefined) {
      
      // Got new websocket (ws-carrier) from tunnelClient.

      var uri = url.parse(request.httpRequest.url, true);
      var sessionId = uri.query.sid;

      if (!_this.awaitingCarrier[sessionId]) {
        _this.log.warn('late websocket carrier ignored - carrierWait expired for tunnel %s', tunnelId);
        request.accept('tunnel-protocol', request.origin).close(); // wasted
        return;
      }

      gotCarrier.emit(sessionId, request);
      return;
    }

    // First connection from tunnelClient. Create new tunnel.

    try {
      uri.query.gw = request.socket.remoteAddress;
    } catch (e) {}

    _this.log.$$TRACE('tunnel request', uri.query);
    
    var defaultForwardingPort = uri.query.port;

    // Accept tunnel control socket

    var wsControl = request.accept('tunnel-protocol', request.origin);
    wsControl.tcpServer = new net.createServer();

    _this.emit('tunnel/create', uri.query, wsControl, wsControl.tcpServer);

    if (_this.startOpen) {

      // Start listening at the forwardingPort

      var fwdingHost = _this.defaultForwardingHostname;
      var fwdingPort = defaultForwardingPort;

      var attempting = true;

      wsControl.tcpServer.on('error', function(e) {
        if (!attempting) {
          // already reached listen
          return;
        }
        _this.emit('tunnel/error', tunnelId, e);
      });

      wsControl.tcpServer.listen(fwdingPort, fwdingHost, function() {
        attempting = false;
        _this.log.$$DEBUG('created forwarding tcp port %s:%s', fwdingHost, fwdingPort);
        _this.emit('tunnel/open', tunnelId, fwdingPort, fwdingHost);
      });

    }

    wsControl.on('message', function(message) {
      if (message.type == 'utf8') {

        var parsing = message.utf8Data.split(":");

        if (parsing[0] === 'HH') {
          var latency = parseInt(parsing[2]);
          if (latency != -1) {
            _this.emit('tunnel/health', tunnelId, {latency: latency, timestamp: parseInt(parsing[1])});
          }
          // Send hh back - clientside calculates message turnaround (latency), result comes in next 'HH'
          wsControl.sendUTF(message.utf8Data + ':' + opts.healthInterval);
          return;
        }

        if (parsing[0] === 'EE') {

          // grep ERROR FEED NOT ACTIVATED
          // carrier/target errors from clisntside

        }

      }
    });

    wsControl.on('close', function(reasonCode, description) {

      // Close from tunnelClient

      var tcpAddr = wsControl.tcpServer.address();

      _this.log.$$DEBUG('got close on tunnel websocket %s \'%s\' %s with reason \'%s\'' , uri.query.id, uri.query.name, uri.query.sn, description);

      if (tcpAddr) {
        _this.log.$$DEBUG("closing tunnel %s tcp server on %s:%s", uri.query.id, tcpAddr.address, tcpAddr.port);
        try {
          wsControl.tcpServer.close();
        } catch (e) {}
        
      }

      _this.emit('tunnel/destroy', tunnelId, { destroyedBy: 'wsControl.close' });
    });
    
    // var count = 0;

    wsControl.tcpServer.on('connection', function(tcpConn) {

      // console.log('connection', count++);

      // Inbound _world_ tcp session at forwardingPort. Pause it and issue instruction for the
      // websocket tunnelClient to create a new websocket (ws-carrier) for the tcp connection. 


      // tcpConn.pause();

      

      var sessionId = _this.genId();
      var tcpAddr = wsControl.tcpServer.address(); // ...only
      var fwdingHost = tcpAddr.address;           // ...for
      var fwdingPort = tcpAddr.port;             // ...logging
                                           

                                            // grep ERROR FEED NOT ACTIVATED
                                           //  |1    
      wsControl.sendUTF("NC:" + sessionId /* + sendErrors + */);
      _this.emit('session/create', {id: sessionId, tunnelId: tunnelId, socket: tcpConn});
      _this.log.$$TRACE('connection at %s:%s requested new ws-carrier %s/%s', fwdingHost, fwdingPort, tunnelId, sessionId);

      _this.awaitingCarrier[sessionId] = setTimeout(function() {
        gotCarrier.emit(sessionId, false);
      }, _this.carrierWait);


      // Await the ws-carrier.

      gotCarrier.once(sessionId, function(request) {

        clearTimeout(_this.awaitingCarrier[sessionId]);
        delete _this.awaitingCarrier[sessionId];

        if (!request) {
          try {
            // destroy throws if already destroyed
            tcpConn.destroy();
          } catch (e) {}
          _this.emit('session/fail', {id: sessionId, tunnelId: tunnelId});
          return;
        }

        // Bind and resume tcpConn.

        var wsCarrier = request.accept('tunnel-protocol', request.origin);

        wsCarrier.on('end', function() {
          _this.emit('session/destroy', {
            id: sessionId,
            tunnelId: tunnelId,
            destroyedBy: 'wsCarrier.end'
          });
          _this.log.$$TRACE('end at %s:%s with ws-carrier %s/%s (from tunnel)', fwdingHost, fwdingPort, tunnelId, sessionId);
        });


        wsCarrier.on('close', function() {
          try {
            tcpConn.destroy();
          } catch (e) {}
          _this.emit('session/destroy', {
            id: sessionId,
            tunnelId: tunnelId,
            destroyedBy: 'wsCarrier.close'
          });
          _this.log.$$TRACE('closed at %s:%s with ws-carrier %s/%s (from tunnel)', fwdingHost, fwdingPort, tunnelId, sessionId);
        });


        wsCarrier.on('error', function(e) {

          // TODO: What to do about __infacing__ errors at tunnel entrance. (#EEE)
          _this.log.warn('error on infacing tunnel connection for %s:%s (ws-carrier %s/%s)', fwdingHost, fwdingPort, tunnelId, sessionId, e);
        });

        tcpConn.on('end', function() {
          _this.emit('session/destroy', {
            id: sessionId,
            tunnelId: tunnelId,
            destroyedBy: 'tcpConn.end'
          });
          _this.log.$$TRACE('end at %s:%s with ws-carrier %s/%s (from source)', fwdingHost, fwdingPort, tunnelId, sessionId);
        });

        tcpConn.on('close', function() {
          try {
            wsCarrier.close();  // per what was in bindSockets_reverse.
          } catch (e) {}
          _this.emit('session/destroy', {
            id: sessionId,
            tunnelId: tunnelId,
            destroyedBy: 'tcpConn.close'
          });
          _this.log.$$TRACE('closed at %s:%s with ws-carrier %s/%s (from source)', fwdingHost, fwdingPort, tunnelId, sessionId);
        });

        tcpConn.on('error', function(e) {

          // TODO: What to do about __outfacing__ errors at tunnel entrance.  (#EEE)
          try {
            tcpConn.destroy();
          } catch (e) {}
          _this.log.warn('error on outfacing tunnel connection at %s:%s (ws-carrier %s/%s)', fwdingHost, fwdingPort, tunnelId, sessionId, e);
        });

        bindSockets(_this.log, wsCarrier, tcpConn);

        // tcpConn.resume();

        _this.emit('session/establish', {id: sessionId, tunnelId: tunnelId, carrier: wsCarrier});
        _this.log.$$TRACE('bound %s:%s to ws-carrier %s/%s', fwdingHost, fwdingPort, tunnelId, sessionId);
        
      });

    });

  });

};


var id   = 9999999999;
var loop = 99999999999; // constant length 11

// Loops after +-2800 connections sustained per second for a year.
// Websocket would need to stay connected that long before it's id is duplicated.

ServerReverse.prototype.genId = function() {
  if (id++ > loop) id = 10000000000;
  return id;
}

module.exports = ServerReverse;
