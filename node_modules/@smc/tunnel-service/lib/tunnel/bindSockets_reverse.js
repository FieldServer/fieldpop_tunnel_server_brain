//###############################################################################
//##
//# Copyright (C) 2014-2015 Andrea Rocco Lotronto
//##
//# Licensed under the Apache License, Version 2.0 (the "License");
//# you may not use this file except in compliance with the License.
//# You may obtain a copy of the License at
//##
//# http://www.apache.org/licenses/LICENSE-2.0
//##
//# Unless required by applicable law or agreed to in writing, software
//# distributed under the License is distributed on an "AS IS" BASIS,
//# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//# See the License for the specific language governing permissions and
//# limitations under the License.
//##
//###############################################################################




// Override WebSocketConnection.sendFrame to emit 'overflow' where necessary.
 
var WebSocketConnection = require('websocket').connection;

WebSocketConnection.prototype.sendFrame = function(frame, cb) {
  this._debug('sendFrame');
  frame.mask = this.maskOutgoingPackets;
  var flushed = this.socket.write(frame.toBuffer(), cb);

  // Only emit 'overflow' on entry into outputBufferFull state because
  // sendFrame can be called multiple times from a single call
  // to WebSocketConnection.sendBytes(), don't want the overflow emitted
  // from each fragment.
  if (!flushed && !this.outputBufferFull) this.emit('overflow');


  this.outputBufferFull = !flushed;
  return flushed;
}

bindSockets = function(log, wsconn, tcpconn) {

  wsconn.__paused = false;
  tcpconn.__paused = false;
  wsconn.on('message', function(message) {
    
    if (message.type === 'utf8') {
      return log.warn('Unsupported message on tunnel carrier.');
    } 
    else if (message.type === 'binary') {
      // log.$$TRACE('WS DATA');
      if (false === tcpconn.write(message.binaryData)) {
        wsconn.socket.pause();
        wsconn.__paused = true;
        // log.$$TRACE('WS pause');
        return "";
      } 
      else {
        if (true === wsconn.__paused) {
          wsconn.socket.resume();
          // log.$$TRACE('WS resume 1');
          return wsconn.__paused = false;
        }
      }
    }
  });

  tcpconn.on("drain", function() {
    wsconn.socket.resume();
    // log.$$TRACE('WS resume 2');
    return wsconn.__paused = false;
  });
  
  wsconn.on("overflow", function() {
    // log.$$TRACE('TCP pause');
    tcpconn.__paused = true;
    return tcpconn.pause();
  });
  
  wsconn.socket.on("drain", function() {
    // log.$$TRACE('TCP resume');
    tcpconn.__paused = false;
    return tcpconn.resume();
  });
  
  tcpconn.on("data", function(buffer) {
    // log.$$TRACE('TCP DATA');
    return wsconn.sendBytes(buffer);
  });
  

};

module.exports = bindSockets;

