//###############################################################################
//##
//# Copyright (C) 2014-2015 Andrea Rocco Lotronto
//##
//# Licensed under the Apache License, Version 2.0 (the "License");
//# you may not use this file except in compliance with the License.
//# You may obtain a copy of the License at
//##
//# http://www.apache.org/licenses/LICENSE-2.0
//##
//# Unless required by applicable law or agreed to in writing, software
//# distributed under the License is distributed on an "AS IS" BASIS,
//# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//# See the License for the specific language governing permissions and
//# limitations under the License.
//##
//###############################################################################

// console.log = function() { // find stray concole.logs
//   process.stdout.write(JSON.stringify(arguments, null, 2));
//   var e = new Error();
//   process.stdout.write('\n');
//   process.stdout.write(e.stack);
//   process.stdout.write('\n');
// }

var WebSocketClient = require('websocket').client;
var net = require("net");


var bindSockets = require("./bindSockets_reverse");

ClientReverse = function(log) {
  this.log = log;
  this.wsClientForControll = new WebSocketClient();
  this.healthReplyWaitTimeout;
}

ClientReverse.prototype.start = function(opts, callback) {

  var _this = this;
  var tunnelId = opts.id;
  var firstFailure = true;
  var healthIntervalRun;
  var latency = -1;

  var parts = opts.forwardTo.split(":"), forwardToHost = parts[0], forwardToPort = parts[1];

  var url = function() {

    // url as function so that changes to opts are represented n retry

    return "" + opts.forwardingService + "/?init=1"     // initializing new tunnel

                               +   "&id="       + tunnelId
                               +   "&version=1"
                               +   "&port="     + (opts.defaultForwardingPort || 0)
                               +   "&to="       + opts.forwardTo
                               +   "&sn="       + opts.serial
                               +   "&hostname=" + opts.hostname      // <-------------- usefull?
                               +   "&ifaces="   + opts.ifaces        // <-------------- usefull?
                               +   "&name="     + opts.name
                               +   "&desc="     + opts.description
                               ;
  };

  // Connect to tunnel server

  var retryInterval = opts.retryStartingInterval;

  this.wsClientForControll.connect(url(), 'tunnel-protocol');
  this.wsClientForControll.on('connect', function(wsControll) {

    _this.reconnectTimeoutClear();

    _this.log.info('tunnelId: %s connected to tunnel server - %s', tunnelId, opts.forwardingService);

    // Reset connection retry mechanism

    firstFailure = true;
    retryInterval = opts.retryStartingInterval;

    wsControll.socket.on('close', function() {
      _this.log.warn('tunnel server %s gone - reconnecting in %d seconds', opts.forwardingService, retryInterval / 1000);
      clearInterval(healthIntervalRun);
      latency = -1;
      setTimeout(function() {
        _this.wsClientForControll.connect(url(), 'tunnel-protocol');
      }, retryInterval);
    });


    clearInterval(healthIntervalRun);
    healthIntervalRun = setInterval(function() {
      wsControll.sendUTF('HH:' + Date.now() + ':' + latency);
      _this.reconnectTimeoutSet(opts, wsControll);
    }, opts.healthInterval);


    wsControll.on('message', function(data) {

      // Received instruction from tunnel server

      var instruction = data.utf8Data.split(":");
      
      if (instruction[0] === 'NC') { // NEW_CARRIER

        // Instruction: Create new websocket (carrier) session to server, sessionId matches
        // up with new tcp request paused and waiting at the forwardingPort.

        var sessionId = instruction[1];
        var sessionUrl = opts.forwardingService + "/?id=" + tunnelId + "&sid=" + sessionId;

        _this.log.$$TRACE('creating ws-carrier %s/%s to %s', tunnelId, sessionId, sessionUrl);

        var sessionWs = new WebSocketClient();


        if (opts.testWithCarrierLag) {
          setTimeout(function() {
            sessionWs.connect(sessionUrl, 'tunnel-protocol');
          }, opts.testWithCarrierLag);
        } else {
          sessionWs.connect(sessionUrl, 'tunnel-protocol');
        }

        sessionWs.on('connect', function(wsCarrier) {
          
          wsCarrier.socket.pause();

          wsCarrier.tunnelId = tunnelId;
          wsCarrier.sessionId = sessionId;

          _this.log.$$TRACE('ws-carrier %s/%s opening connection to %s:%s', tunnelId, sessionId, forwardToHost, forwardToPort);
          _this.tcpConnection(instruction, wsControll, wsCarrier, forwardToHost, forwardToPort);
        
        });

        return;
      } 
      
      if (instruction[0] === 'HH') {
        var sentAt = parseInt(instruction[1]);
        var serverHealthInterval = parseInt(instruction[3]);
        _this.reconnectTimeoutClear();
        if (!isNaN(serverHealthInterval) && opts.healthInterval != serverHealthInterval) {
          _this.log.$$DEBUG('server reset healthInterval from %s to %s', opts.healthInterval, serverHealthInterval);
          clearInterval(healthIntervalRun);
          healthIntervalRun = setInterval(function() {
            wsControll.sendUTF('HH:' + Date.now() + ':' + latency);
            _this.reconnectTimeoutSet(opts, wsControll);
          }, opts.healthInterval = serverHealthInterval);

        }
        // latency = turnaround for request/response / 2
        latency = Math.round((Date.now() - sentAt) / 2);
        return;
      }
    });
  });

  this.wsClientForControll.on('connectFailed', function(error) {

    if (firstFailure) {
      _this.log.warn('ws connect error, will retry endlessly', error);
      _this.log.$$TRACE('retry %s in %d seconds', url(), retryInterval / 1000);
      setTimeout(function() {
        _this.wsClientForControll.connect(url(), 'tunnel-protocol');
      }, retryInterval);
      firstFailure = false;
      return;
    }

    retryInterval *= opts.retryIntervalMultiplier;
    if (retryInterval > opts.retryIntervalMax) {
      retryInterval = opts.retryIntervalMax;
    }
    _this.log.$$TRACE('retry %s in %d seconds', url(), retryInterval / 1000);
    setTimeout(function() {
      _this.wsClientForControll.connect(url(), 'tunnel-protocol');
    }, retryInterval);

  });


  // TODO: options about when to callback

  callback();

};

ClientReverse.prototype.tcpConnection = function(instruction, wsControll, wsCarrier, forwardToHost, forwardToPort){

  // Connect to 'forwardTo', bind and resume.

  var tcpConn = net.connect({
    port: forwardToPort,
    host: forwardToHost
  },function(){
    /* ??? */
  });

  var _this = this;

  var sessionId = instruction[1];

  // grep ERROR FEED NOT ACTIVATED (server side switches it on)
  var sendErrors = instruction.length > 2 && instruction[2] == '1';

  tcpConn.on("connect",function() {

    bindSockets(_this.log, wsCarrier, tcpConn);
    wsCarrier.socket.resume();

    _this.log.$$TRACE('bound ws-carrier %s/%s to %s:%s', wsCarrier.tunnelId, wsCarrier.sessionId, forwardToHost, forwardToPort);
  });

  // Closing prematurely when paused, selectively leave close upto the tunnel in `wsCarrier.socket.on('close'` below
  tcpConn.on('close', function() {
    if (tcpConn.__paused) return;
    wsCarrier.close();
    _this.log.$$TRACE('ws-carrier %s/%s closed (from target)', wsCarrier.tunnelId, wsCarrier.sessionId);
  });

  // tcpConn.on('end', function() {
  //   // wsCarrier.close();
  //   _this.log.$$TRACE('ws-carrier %s/%s session to %s:%s end (from target)', wsCarrier.tunnelId, wsCarrier.sessionId, forwardToHost, forwardToPort);
  // });


  tcpConn.on('error', function(e) {
    try {
      tcpConn.destroy();
    } catch (e) {}
    
    if (sendErrors) {
      try {
        wsControll.sendUTF('EE:targetTCP:' +sessionId + ':' + Date.now() + ':' + e.name + ':' + e.message);
      } catch (e) {}
    }
    _this.log.warn('error in ws-carrier %s/%s session to %s:%s (from target)', wsCarrier.tunnelId, wsCarrier.sessionId, forwardToHost, forwardToPort, e);
  });



  wsCarrier.socket.on('close', function() {
    tcpConn.destroy();
    _this.log.$$TRACE('ws-carrier %s/%s closed (from tunnel)', wsCarrier.tunnelId, wsCarrier.sessionId);
  });

  wsCarrier.socket.on('end', function() {
    _this.log.$$TRACE('ws-carrier %s/%s session to %s:%s end (from tunnel)', wsCarrier.tunnelId, wsCarrier.sessionId, forwardToHost, forwardToPort);
  });

  wsCarrier.socket.on('error', function(e) {
    if (sendErrors) {
      try {
        wsControll.sendUTF('EE:targetWS:' +sessionId + ':' + Date.now() + ':' + e.name + ':' + e.message);
      } catch (e) {}
    }
    _this.log.warn('error in ws-carrier %s/%s session to %s:%s (from tunnel)', wsCarrier.tunnelId, wsCarrier.sessionId, forwardToHost, forwardToPort, e);
  });


}


ClientReverse.prototype.reconnectTimeoutSet = function(opts, wsControll) {

  var _this = this;

  // If not already waiting for health response, set timeout to disconnect if no reply.
  // this timeout is cleared and reset when the HH reply arrives.

  if (!this.healthReplyWaitTimeout) {

    this.healthReplyWaitTimeout = setTimeout(function() {

      clearTimeout(_this.healthReplyWaitTimeout);

      try {

        // No HH reponse from server, initiate reconnect
        wsControll.socket.destroy();

      } catch (e) {}

    }, opts.healthReconnectTimeout);

  }

}

ClientReverse.prototype.reconnectTimeoutClear = function() {

  clearTimeout(this.healthReplyWaitTimeout);
  delete this.healthReplyWaitTimeout;

}



module.exports = ClientReverse;
