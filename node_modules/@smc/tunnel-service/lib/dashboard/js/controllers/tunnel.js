gridApp.controller('tunnel', 
  ['$scope', 'timestamp',
  function($scope, timestamp) {

    $scope.timestamp = timestamp;

    var _this = this;

    $scope.tunnels = [];

    $scope.url = function() {
      return 'http://' + $scope.selectedTunnel.forwarding.address + ':' + $scope.selectedTunnel.forwarding.port
    }

  	$scope.refreshTunnels = function(server){
      $scope.gridAppService.utils.notify('fetching tunnels');

      var tunnelExchange = _this.gatewayMeshClient.exchange['websocket-tunnel'];

      tunnelExchange.listTunnels(server)

      .then(function(tunnels) {
        $scope.tunnels = tunnels;
        $scope.gridAppService.utils.notify('tunnels listed', 'success', 1500);

        if (tunnels.length == 1) {
          $scope.selectTunnel(tunnels[0]);
        }
      })
      .catch(function() {
        $scope.gridAppService.utils.notify('tunnel listing failed', 'danger');
      })
      
  	}

  	$scope.$on('AUTH-OK', function(evt, data){
		  _this.gatewayMeshClient = $scope.gridAppService.getClient();

      var tunnelEvents = _this.gatewayMeshClient.event['websocket-tunnel'];

      // TODO: Don't re-subscribe on 2nd auth
      tunnelEvents.on('tunnel/*', function(tunnel, meta) {

        var event = meta.path.match(/.*\/(.*)/)[1];

        // if (event !== 'health')
        //   console.log('tunnel event', event, tunnel);

        if (event == 'health' || event == 'open' || event == 'close' || event == 'error' || event == 'reset') {
          // update keys on the matching tunnel
          $scope.tunnels.forEach(function(exists) {
            if (exists.id == tunnel.id) {
              Object.keys(tunnel).forEach(function(key) {
                exists[key] = tunnel[key];
              });
            }
          });
          if ($scope.selectedTunnel && $scope.selectedTunnel.id == tunnel.id) {
            $scope.selectedTunnel = tunnel;
          }

          $scope.$apply();
          return;
        }

        if (event == 'destroy') {
          $scope.tunnels.forEach(function(exists, i) {
            if (exists.id == tunnel.id) {
              $scope.tunnels.splice(i, 1);
            }
            if ($scope.selectedTunnel && $scope.selectedTunnel.id == tunnel.id) {
              // selected tunnel has shutdown,
              // inform session list via null emit to clear listing
              $scope.selectedTunnel = null;
              $scope.gridAppService.broadcast('TUNNEL-SELECTED', null);
            }
          });
          $scope.$apply();
          return;
        }

        if (event == 'create') {
          var found = false;
          $scope.tunnels.forEach(function(exists, i) {
            if (exists.id == tunnel.id) {
              found = true;
              $scope.tunnels.splice(i, 1, tunnel);
              $scope.selectedTunnel = tunnel;
            }
          });
          if (! found) {
            $scope.tunnels.unshift(tunnel);
            if ($scope.tunnels.length == 1) $scope.selectedTunnel = tunnel;
          }
          $scope.$apply();
          return;
        }

        console.warn('unhandled tunnel event', meta.path, tunnel);

      });


      tunnelEvents.on('session/fail', function(session, meta) {

        var tunnelId = session.tunnelId;
        var changed = false;
        $scope.tunnels.forEach(function(update) {
          if (update.id == tunnelId) {
            update.failures.count ++;
            update.failures.timestamp = Date.now();
            changed = true;
          }
        });
        if (changed) $scope.$apply();

      });

	  });

  	$scope.$on('SERVER-SELECTED', function(evt, server){
      $scope.selectedTunnel = null;
		  $scope.refreshTunnels(server);
      $scope.selectedServer = server;
		  // console.log('server selected',server);
	  });

    $scope.selectTunnel = function(tunnel){

      console.log('select tunnel', tunnel);

      $scope.selectedTunnel = tunnel;
      $scope.gridAppService.broadcast('TUNNEL-SELECTED', tunnel);

      // pointing the ui at the actual model means the textboxes update when
      // the tunnel health message arrives (and wipes out partial edit)
      $scope.forwardingPort = $scope.selectedTunnel.defaultForwardingPort;
      $scope.forwardingHostname = $scope.selectedServer.wsOpts.forwardingHostname;

      $scope.forwarding = {
        hostname: $scope.selectedServer.wsOpts.forwardingHostname,
        port: $scope.selectedTunnel.defaultForwardingPort
      }

    }

    $scope.openSelectedTunnel = function(){
      var tunnelExchange = _this.gatewayMeshClient.exchange['websocket-tunnel'];

      tunnelExchange.openTunnel($scope.selectedTunnel, $scope.forwarding)
      .then(function(tunnel) {
        console.log('opened tunnel', tunnel);
        $scope.selectedTunnel = tunnel;
        $scope.$apply();
      })
      .catch(function(error) {        
        $scope.gridAppService.utils.notify('opening tunnel: ' + error, 'danger');

      });

    }

    $scope.closeSelectedTunnel = function(){
      var tunnelExchange = _this.gatewayMeshClient.exchange['websocket-tunnel'];

      tunnelExchange.closeTunnel($scope.selectedTunnel)
      .then(function(tunnel) {
        console.log('closed tunnel', tunnel);
        $scope.selectedTunnel = tunnel;
        $scope.$apply();
      })
      .catch(function(error) {        
        $scope.gridAppService.utils.notify('closing tunnel: ' + error, 'danger');

      });
    }


    $scope.resetSelectedTunnel = function(){
      var tunnelExchange = _this.gatewayMeshClient.exchange['websocket-tunnel'];

      // $scope.gridAppService.utils.notify('kicked tunnel client websocket - awaiting reconnect');

      tunnelExchange.resetTunnel($scope.selectedTunnel)
      .then(function(tunnel) {
        console.log('reset tunnel', tunnel);
        $scope.selectedTunnel = tunnel;
        $scope.$apply();
      })
      .catch(function(error) {        
        $scope.gridAppService.utils.notify('reset tunnel: ' + error, 'danger');

      });
    }

  }]
);
