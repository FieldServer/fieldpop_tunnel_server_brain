gridApp.controller('session', 
	['$scope', 'timestamp',
	function($scope, timestamp) {

    $scope.timestamp = timestamp;

    var _this = this;

    $scope.sessions = [];
	
		$scope.selectSession = function(session) {
      console.log('select session', session);
			$scope.selectedSession = session;
		}

    // start loop to update session if there is one

    setInterval(function() {

      var session = $scope.selectedSession;
      var tunnelExchange; 
      try {
        tunnelExchange = _this.gatewayMeshClient.exchange['websocket-tunnel'];
      } catch(e) {}

      if (!session || !tunnelExchange) return;

      tunnelExchange.getSession(session).then(function(update) {

        // update original ref so that it gets to the table too

        Object.keys(update).forEach(function(key) {
          session[key] = update[key];
        });

        $scope.$apply();

      }).catch(function() {})

    }, 1000) // calculations rely on this being one second



    $scope.selectedSessionState = function() {
      var session = $scope.selectedSession;
      if (!session) return;
      var state, age;
      if (session.created) {
        state = 'awaiting carrier for ' + timestamp.toAge(session.created);
      }
      if (session.established) {
        state = 'established for ' + timestamp.toAge(session.established);
      }
      return state
    }


    $scope.refreshSessions = function(tunnel) {
      $scope.gridAppService.utils.notify('fetching sessions');

      var tunnelExchange = _this.gatewayMeshClient.exchange['websocket-tunnel'];

      tunnelExchange.listSessions(tunnel)

      .then(function(sessions) {
        $scope.sessions = sessions;
        $scope.$apply();
        $scope.gridAppService.utils.notify('sessions listed', 'info', 2000);
      })
      .catch(function(e) {
        $scope.gridAppService.utils.notify('session listing failed', 'danger');
      })

    }

    $scope.$on('SERVER-SELECTED', function(evt, server){
      $scope.sessions = [];
      selectedTunnel = null;
      // console.log('server selected',server);
    });

    $scope.$on('TUNNEL-SELECTED', function(evt, tunnel) {
      $scope.sessions = [];
      selectedTunnel = null;

      if (!tunnel) return;
      
      if (tunnel.state.value == 'open'){
        $scope.refreshSessions(tunnel);
        selectedTunnel = tunnel;
      }
      
    });

    $scope.$on('AUTH-OK', function(evt, data){
      _this.gatewayMeshClient = $scope.gridAppService.getClient();

      var tunnelEvents = _this.gatewayMeshClient.event['websocket-tunnel'];

      // setInterval(function() {
      //   // refresh the view to update the time values
      //   $scope.$apply();
      // }, 2000);

      tunnelEvents.on('session/*', function(session, meta) {

        var event = meta.path.match(/.*\/(.*)/)[1];

        if (event == 'establish') {
          // update keys on the matching session
          console.log('event "%s"', event, session);
          $scope.sessions.forEach(function(exists) {
            if (exists.id == session.id) {
              Object.keys(session).forEach(function(key) {
                exists[key] = session[key];
              });
            }
          });
          $scope.$apply();
          return;
        }

        if (event == 'destroy' || event == 'fail') {
          $scope.sessions.forEach(function(exists, i) {
            if (exists.id == session.id) {
              $scope.sessions.splice(i, 1);
            }
          });
          $scope.$apply();
          return;
        }

        if (event == 'create') {
          $scope.sessions.unshift(session);
          $scope.$apply();
          return;
        }

        console.warn('unhandled session event', meta.path, tunnel);

      });
    });

	}]
);
