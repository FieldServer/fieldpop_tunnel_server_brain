module.exports = WebsocketTunnelController;

module.exports.ServerOptions = ServerOptions;
module.exports.ClientOptions = ClientOptions;
module.exports.Proxy = require('./proxy/index');

var WS_SERVER_PORT = parseInt(process.env.WS_SERVER_PORT);
var WS_SERVER_HOSTNAME = process.env.WS_SERVER_HOSTNAME;
var FORWARDING_HOSTNAME = process.env.FORWARDING_HOSTNAME;

var Promise = require('bluebird')
  , wst = require('./tunnel/wst')
  , shortid = require('shortid')
  , os = require('os')
  , enabled
  , terminalDone
  ;


/**
 * Options for createServer(opts) or createServers(optsArray).
 *
 * @api public
 * @constructor
 *
 * For information.
 *
 */

function ServerOptions() {

  // an optional name can be assigned to each ws tunnel server
  this.name = 'untitled';  // <serverName> defaults to meshname

  // an optional description to extend meaningfullness to operators
  // or for ui search functionality
  this.description = '';

  // reverse tunnel - no other mode is supported.
  this.mode = 'reverse';

  // the default interface for the _world_ facing tunnel entrances
  this.forwardingHostname = '0.0.0.0';

  // which iface on the server to listen for ws tunnel init requests from client
  // - defaults to $happn.info.datalayer.address
  this.wshostname = WS_SERVER_HOSTNAME;

  // which port listens for ws tunnel init requests from client
  this.wsport = WS_SERVER_PORT || 10000;

  // milliseconds before assuming request for a new websocket carrier from client has failed
  // and the new tcp request from _world_ cannot be serviced. 
  this.carrierWait = 10000;

  // milliseconds between health pingpongs emitted from clients
  // (this overrides the client's own healthInterval if set)
  this.healthInterval = null;
  // eg. (setting interval on the fly)
  //   > node
  //   __node> server = $happn._mesh.elements.wsTunnelController.module.instance.servers['localhost:10000']
  //   __node> server.wsOpts.healthInterval = 10; // lunacy! all tunnels pinpong every 10ms and emit health...


  // when tunnels are initiated they only go to listening at the forwardingPort if true
  // - true uses client's `defaultForwardingPort` or defualt next free port
  // - if false: use openTunnel() and closeTunnel()
  this.startOpen = true;


  // Ability to tailor datalayer emits.
  this.emits = {

    // on a new tunnelServer being created
    'server/create': enabled = true,

    // on the tunnelClient attaching to create the tunnel
    'tunnel/create': enabled = true,

    // tunnel starts listening at the forwardingPort, see tunnelOpen(), tunnelClose()
    'tunnel/open': enabled = true, // <---------------------------------------------- provides .forwarding for addr and port 

    // tunnel stops listening at the forwardingPort, see tunnelOpen(), tunnelClose()
    'tunnel/close': enabled = true,

    // tunnel enters error state
    'tunnel/error': enabled = true,

    // tunnel health, latency report (emitted each tunnel every healthInterval)
    'tunnel/health': enabled = true,

    // tunnel disconnection from client
    'tunnel/destroy': enabled = true,

    // tunnel was called to reset (forced disconnection / await reconnect)
    'tunnel/reset': enabled = true,

    // with each new _world_ connection at the forwardingPort
    'session/create': false,

    // when the new connection is attached to it's tunnel (ws-carrier)
    'session/establish': false,

    // when the tunnel (server/client) fails to create a ws-carrier for the new connection
    // (see opts.carrierWait)
    'session/fail': true,

    // when the connection from world terminates normally (completes)
    'session/destroy': false,
  };

};





/**
 * Options for createClient(opts) or createClients(optsArray).
 *
 * @api public
 * @constructor
 *
 * For information.
 *
 */

function ClientOptions() {

  this.name = 'untitled';

  this.description = '';

  this.mode = 'reverse';

  // Server on accessable network running this module. (createServer())
  this.forwardingService = 'ws://public.server.com:10000';

  // port at the server (tunnel "entrance") to listen at
  // if zero or undefined, server assigns default next free
  this.defaultForwardingPort = 0;

  // tunnel "exit" where 'hostname.local' is a host resolvable by __this__ client
  // defaults to client's datalayer address
  this.forwardTo = 'hostname.local:3000';

  // client connect failed: retry after...
  this.retryStartingInterval = 2000;

  // client connect failed again: multiply retry interval by...
  this.retryIntervalMultiplier = 1.5;

  // don't let retry interval exceed ms value...
  this.retryIntervalMax = 60000;

  // interval between pingpong on the websocket control connection
  // (see Tunnel.health)
  this.healthInterval = 10000;

  // if healthReconnectTimeout passes after after health ping without
  // receiving health reply, the server is assumed disconnected and
  // the client starts the reconnect loop
  this.healthReconnectTimeout = 60000;


  // test slow carrier response to session create
  this.testWithCarrierLag = 0;

};







/**
 * Instance of a tunnel session created between tunnel client and tunnel server.
 *
 * @api private
 * @constructor
 *
 * One of these is created for every tcp session initiated from 'world' through 'tunnel'.
 * 
 * The following steps are taken:
 * ------------------------------
 *
 * 1. The new socket session 'stream' at the tunnel entrance port is __paused__.
 *
 * 2. The tunnel server creates an id and emits it to the tunnel client via the
 *    control websocket (the initial websocket from the tunnel client)
 *
 * 3. The tunnel client receives this id and creates a new tcp connection to the
 *    destination port (the 'forwardTo').
 *
 * 4. The tunnel client also creates a new websocket session to the tunnel server,
 *    submitting, with that request, the id created by the server.
 *
 * 5. Client also binds this new websocket session to the tcp session it created
 *    to the destination port (the 'forwardTo').
 * 
 * 6. And the tunnel server binds the new websocket session which the tunnel client
 *    just created, per the id, to the original requesting session from 'world'.
 *
 * 7. The server then __resumes__ the orignal 'stream', now streaming into the websocket.
 *
 * 8. The operating tunnel.
 *
 *
 *
 * ## hole_2 - when tunnel spans a terrible/intermittent network
 * 
 *             Errors:  grep -r \#EEE lib/
 * 
 *
 *
 * 9. When the outermost ports on either side of the tunnel receive a close/end
 *    that ending of session is propagated across the tunnel.
 * 
 */

function Session(props) {

  // sessionId
  this.id = props.id;
  this.tunnelId = props.tunnelId;
  this.serverId = props.serverId;

  // timestamps
  this.created = Date.now();
  this.established = null;
  this.destroyed = null;

  // the tcp connection to _world_ that initiated this session
  Object.defineProperty(this, 'socket', {
    value: props.socket
  });

  // the remote address of _world_
  Object.defineProperty(this, 'remote', {
    enumerable: true,
    get: function() {
      return {
        address: props.socket.remoteAddress,
        port: props.socket.remotePort
      }
    }
  });

  // the websocket carrier that spans the tunnel
  Object.defineProperty(this, 'carrier', {
    value: null // set on 'session/established' event
  });

  // usage
  Object.defineProperty(this, 'bytes', {
    enumerable: true,
    get: function() {
      return {
        // bytes sent into tunnel from _world_
        in: props.socket.bytesRead,
        // bytes sent outof tunnel to _world_
        out: props.socket.bytesWritten
      }
    }
  });

}






/**
 * Instance of a Tunnel created when tunnel client connects to tunnel server.
 *
 * @api private
 * @constructor
 *
 * Collection in server.tunnels.
 *
 */
function Tunnel(props, server, wsControl, tcpServer) {

  // Id at client (tunnelId)
  this.id = props.id;
  this.serverId = server.id;

  // Each tunnel has multiple socket sessions.
  // One per 'world' session through the tunnel.
  // Not enumerable. Potentially too big.
  Object.defineProperty(this, 'sessions', {
    value: {}
  });

  var now = Date.now();

  this.created = now;

  // The state of this tunnel.
  // 'open'   - after event 'tunnel/open'
  // 'closed' - after event 'tunnel/create', 'tunnel/close'
  // 'error'  - after event 'tunnel/error'
  this.state = {
    timestamp: now,
    value: 'closed' // starting state
  }

  // Name as configured at client.
  this.name = props.name;

  // Description as configired at client.
  this.description = props.desc;

  // Tunnel exit (at client or client accessable node).
  this.forwardTo = props.to;

  // Client's gateway (where the tunnel client's traffic appears to originate)
  this.gateway = props.gw;

  // Clients serial number
  this.serial = props.sn;

  // Client's (own notion) of hostname
  this.hostname = props.hostname;

  // Client's (own) network interfaces (their private network)
  this.ifaces = props.ifaces;

  // Client's choice of port to forward
  this.defaultForwardingPort = props.port;

  // Websocket to tunnel client (hidden? to prevent servialization on emit)
  Object.defineProperty(this, 'wsControl', {
    value: wsControl
  });

  // Tcp server to _world_ (hidden? to prevent servialization on emit)
  Object.defineProperty(this, 'tcpServer', {
    value: tcpServer
  });

  // Tunnel entrance address.
  var _this = this;
  Object.defineProperty(this, 'forwarding', {
    enumerable: true,
    get: function() {
      try {
        return _this.tcpServer.address();
      } catch (e) {}
    }
  });

  // Tunnel latency, milliseconds between tunnel client's ping and tunnel server's pong
  this.health = {
    timestamp: now,
    latency: -1
  }

  // Count of session carrier request failures
  this.failures = {
    count: 0,
    timestamp: undefined
  }

}






/**
 * Instance of a websocket tunnel server created and managed by this controller.
 *
 * @api private
 * @constructor
 *
 */

function Server(props, wst) {

  var _this = this;

  var $happn = props.$happn;

  var emits = props.emits || {
    // defaults
    'server/create': true,
    'tunnel/create': true,
    'tunnel/open': true,
    'tunnel/close': true,
    'tunnel/error': true,
    'tunnel/health': true,
    'tunnel/destroy': true,
    'tunnel/reset': true,
    'session/create': false,
    'session/establish': false,
    'session/fail': true,
    'session/destroy': false,
  }

  this.id = props.id; // TODO: perhaps key on 'name', no 'id'

  Object.defineProperty(this, 'tunnels', {
    value: {}
  });

  Object.defineProperty(this, 'destroyedTunnels', {
    value: {}
  });

  this.created = Date.now();

  this.name = props.name || $happn.info.mesh.name;

  this.description = props.description || '';

  this.mode = props.mode;

  // the resulting listening websocket server url
  this.url = props.url;

  // opts that initialized the websocket (waiting to tunnelClient)
  this.wsOpts = props.wsOpts;

  // the instanceof WstServerReverse
  Object.defineProperty(this, 'wst', {value: wst});



  wst.on('tunnel/create', function(request, wsControl, tcpServer) {

    var tunnel = new Tunnel(request, _this, wsControl, tcpServer);
    _this.tunnels[tunnel.id] = tunnel;

    // TODO: handle already exists (is same?, ws-control reconnecting?)

    if (emits['tunnel/create']) {
      $happn.emit('tunnel/create', tunnel);
    }

  });

  wst.on('tunnel/reset', function(tunnelId) {
    var tunnel = _this.tunnels[tunnelId];
    if (!tunnel) return;
    tunnel.state.value = 'reset';
    tunnel.state.timestamp = Date.now();

    // delete tunnel.state.error;

    if (emits['tunnel/reset']) {
      $happn.emit('tunnel/reset', tunnel);
    }

    // remove tunnel, wait for new one
    delete _this.tunnels[tunnelId];

  });

  wst.on('tunnel/open', function(tunnelId, forwardingHost, forwardingPort) {
    var tunnel = _this.tunnels[tunnelId];
    if (!tunnel) return;
    tunnel.state.value = 'open';
    tunnel.state.timestamp = Date.now();
    delete tunnel.state.error;

    $happn.log.info('opened tunnel %s/%s', _this.name, tunnel.name);

    if (emits['tunnel/open']) {
      $happn.emit('tunnel/open', tunnel);
    }
  });

  wst.on('tunnel/close', function(tunnelId) {
    var tunnel = _this.tunnels[tunnelId];
    if (!tunnel) return;
    tunnel.state.value = 'closed';
    tunnel.state.timestamp = Date.now();
    delete tunnel.state.error;

    $happn.log.info('closed tunnel %s/%s', _this.name, tunnel.name);

    if (emits['tunnel/close']) {
      $happn.emit('tunnel/close', tunnel);
    }
  });

  wst.on('tunnel/error', function(tunnelId, e) {
    var tunnel = _this.tunnels[tunnelId];
    if (!tunnel) return;
    tunnel.state.value = 'error';
    tunnel.state.timestamp = Date.now();

    tunnel.state.error = {};
    tunnel.state.error.name = e.name;
    tunnel.state.error.message = e.message;
    Object.keys(e).forEach(function(ek) {
      tunnel.state.error[ek] = e[ek];
    });

    if (emits['tunnel/error']) {
      $happn.emit('tunnel/error', tunnel);
    }

  });

  wst.on('tunnel/health', function(tunnelId, info) {
    var tunnel = _this.tunnels[tunnelId];
    if (!tunnel) return;
    // reset error?
    tunnel.health = info;

    if (emits['tunnel/health']) {
      $happn.emit('tunnel/health', tunnel);
    }

  });


  wst.on('tunnel/destroy', function(tunnelId, info) {
    var tunnel = _this.tunnels[tunnelId];
    if (!tunnel) return;

    tunnel.destroyed = Date.now();
    tunnel.destroyedBy = info.destroyedBy;

    _this.destroyedTunnels[tunnelId] = tunnel;
    delete _this.tunnels[tunnelId];

    // TODO: the session/destroy(s) for this tunnel are firing after the tunnel/destroy
    //       so if the tunnel/destroy deleted the tunnel from the collection then the
    //       session/destroy has no tunnel reference
    setTimeout(function() {
      delete _this.destroyedTunnels[tunnelId];
    }, 10000);

    if (emits['tunnel/destroy']) {
      $happn.emit('tunnel/destroy', tunnel);
    }

  });


  wst.on('session/create', function(info) {

    info.serverId = _this.id;

    var session = new Session(info);
    var tunnel = _this.tunnels[info.tunnelId];
    if (!tunnel) return;
    tunnel.sessions[session.id] = session;

    if (emits['session/create']) {
      $happn.emit('session/create', session);
    }

  });

  wst.on('session/establish', function(info) {

    var tunnel = _this.tunnels[info.tunnelId];
    if (!tunnel) return;
    var session = tunnel.sessions[info.id];
    if (!session) return;

    session.established = Date.now();
    session.carrier = info.carrier;

    if (emits['session/establish']) {
      $happn.emit('session/establish', session);
    }

  });

  wst.on('session/fail', function(info) {

    var tunnel = _this.tunnels[info.tunnelId];
    if (!tunnel) return;
    var session = tunnel.sessions[info.id];
    if (!session) return;

    tunnel.failures.count++;
    tunnel.failures.timestamp = Date.now();

    delete tunnel.sessions[info.id];

    // TODO: noisey if target is down but tunnel is open!! 
    //       some kind of repetition suppresion may be required
    if (emits['session/fail']) {
      $happn.emit('session/fail', session);
    }

  });          

  wst.on('session/destroy', function(info) {

    var tunnel = _this.tunnels[info.tunnelId] || _this.destroyedTunnels[info.tunnelId];

    if (!tunnel) return;

    var session = tunnel.sessions[info.id];

    if (!session) return; // session/destroy can be emitted from multiple sources....x

    session.destroyed = Date.now();
    session.destroyedBy = info.destroyedBy;
    delete tunnel.sessions[info.id];  // x.... making this delete important

    if (emits['session/destroy']) {
      $happn.emit('session/destroy', session);
    }

  });

  if (emits['server/create']) {
    $happn.emit('server/create', this);
  }

}






/**
 * Instance of a websocket tunnel client created and managed by this controller.
 *
 * @api private
 * @constructor
 *
 */

 function Client(props, wst) {

  this.id = props.id;
  this.serial = props.serial;
  this.created = Date.now();
  this.mode = props.mode;
  this.name = props.name;
  this.description = props.description;
  this.hostname = props.hostname;
  this.ifaces = props.ifaces;

  Object.defineProperty(this, 'wst', {value: wst});
 }








/**
 * Websocket tunnel controller.
 *
 * @api public
 * @constructor
 *
 * Any number of these can be initialized into the mesh. But only one is preferrable
 * because it can start multiple tunnels all of which can then be monitored and controlled
 * by the one instance of the provided widget(s) 
 *
 */

function WebsocketTunnelController() {

  // The clientside. See this.createServer()

  this.servers = {};

  // The clientside. See this.createClient()

  this.clients = {};

};

/**
 * Initiate the server side of a tunneling pair.
 *
 * @api public
 * @param {ServerOptions} opts
 * @param {Function} callback
 *
 */

WebsocketTunnelController.prototype.createServer = function($happn, opts, callback) {

  loadTerminal($happn, this);

  if (typeof opts == 'function') {
    callback = opts;
    opts = {};
  }

  opts.mode = opts.mode || 'reverse';
  opts.wsport = opts.wsport || 10000;

  if (opts.mode !== 'reverse') {
    return callback(new Error('Only reverse mode supported in tunnel server'));
  }

  $happn.log.$$DEBUG('start tunnel server', opts);

  var reverseServer = new wst.ServerReverse($happn.log);

  var wstOpts = {
    wshostname: WS_SERVER_HOSTNAME || opts.wshostname || $happn.info.datalayer.address.address,
    wsport: WS_SERVER_PORT || opts.wsport,
    forwardingHostname: FORWARDING_HOSTNAME || opts.forwardingHostname || '0.0.0.0',
    startOpen: typeof opts.startOpen == 'boolean' ? opts.startOpen : true,
    carrierWait: opts.carrierWait || 10000,
    healthInterval: opts.healthInterval,
  };

  var _this = this;

  reverseServer.start(wstOpts, function(e, url) {

    if (e) {
      return callback(e);
    }

    var id = opts.id || wstOpts.wshostname + ':' + wstOpts.wsport;

    // Create new Server for storage in the collection.

    var server = new Server({
      id: id,
      url: url,
      wsOpts: wstOpts,
      mode: opts.mode,
      name: opts.name,
      description: opts.description,
      $happn: $happn,
      emits: opts.emits,
    }, reverseServer);            

    _this.servers[server.id] = server;

    callback(e, server);

  });

};

/**
 * Initiate multiple server sides for tunneling.
 *
 * @api public
 * @param {Array} optsArray of ServerOptions
 * @param {Function} callback
 *
 */

WebsocketTunnelController.prototype.createServers = function($happn, optsArray, callback) {

  // Calls back with only the first error.
  //
  // Some servers may have started even on error.
  //
  // TODO: ??make transactional, if any fail, stop those that started (undo), and callback error
  //       ??or, callback with multiple errors and leave successes running


  // All are started concurrently

  var _this = this;

  Promise.all(optsArray.map(function(opts) {

    return new Promise(function(resolve, reject) {

      _this.createServer($happn, opts, function(e, url) {

        if (e) return reject(e);

        return resolve(url);

      });

    });

  }))

  .then(function(urls) {
    callback(null, urls);
  })

  .catch(callback);

}

/**
 * Properly stop tunnel server
 *
 * @api public
 * @param {Function} callback
 *
 * Sends propper termination to remote clients (browsers) using the tunnel 
 * and terminates carriers as necessary
 * 
 */

WebsocketTunnelController.prototype.destroyServer = function($happn, opts, callback) {
  callback(new Error('not implemented'));
};


/**
 * List servers in this controller.
 *
 * @api public
 * @param {Query} query (not implemented)
 * @param {Function} callback
 *
 */
 
WebsocketTunnelController.prototype.listServers = function($happn, query, callback) {

  if (typeof query == 'function') {
    callback = query;
    query = {};
  }

  var _this = this;

  callback(null, Object.keys(this.servers).map(function(id) {
    return _this.servers[id];
  }));
}

/**
 * Get a server
 *
 * @api public
 * @param {Server|{id: String}} server
 * @param {Function} callback
 *
 */

WebsocketTunnelController.prototype.getServer = function($happn, server, callback) {

  if (!server.id) return callback(new Error('missing server.id'));

  if (!this.servers[server.id]) return callback(new Error('no server with id ' + server.id));

  callback(null, this.servers[server.id]);

}

/**
 * List tunnels
 *
 * @api public
 * @param {Server|{id: String}} server
 * @param {Function} callback
 *
 */

WebsocketTunnelController.prototype.listTunnels = function($happn, server, callback) {

  if (!server.id) return callback(new Error('missing server.id'));

  if (!this.servers[server.id]) return callback(new Error('no server with id ' + server.id));

  server = this.servers[server.id];

  var tunnels = server.tunnels; // TODO: big? paginate?

  callback(null, Object.keys(tunnels).map(function(id) {
    return tunnels[id];
  }));

}

/**
 * Get a tunnel
 *
 * @api public
 * @param {Tunnel|{serverId: String, id: String}} tunnel
 * @param {Function} callback
 *
 */

WebsocketTunnelController.prototype.getTunnel = function($happn, tunnel, callback) {

  if (!tunnel.id) return callback(new Error('missing tunnel.id'));

  if (!tunnel.serverId) return callback(new Error('missing tunnel.serverId'));

  if (!this.servers[tunnel.serverId]) return callback(new Error('no server with id ' + tunnel.serverId));

  var server = this.servers[tunnel.serverId];

  var tunnels = server.tunnels;

  if (!tunnels[tunnel.id]) return callback(new Error('no tunnel with id ' + tunnel.id));

  tunnel = tunnels[tunnel.id];

  callback(null, tunnel);

}


/**
 * List sessions
 *
 * @api public
 * @param {Tunnel|{serverId: String, id: String}} tunnel
 * @param {Function} callback
 *
 */

WebsocketTunnelController.prototype.listSessions = function($happn, tunnel, callback) {

  if (!tunnel.serverId) return callback(new Error('missing tunnel.serverId'));
  if (!tunnel.id) return callback(new Error('missing tunnel.id'));

  if (!this.servers[tunnel.serverId]) return callback(new Error('no server with id ' + tunnel.serverId));

  var server = this.servers[tunnel.serverId];

  var tunnels = server.tunnels;

  if (!tunnels[tunnel.id]) return callback(new Error('no tunnel with id ' + tunnel.id));

  tunnel = tunnels[tunnel.id];

  var sessions = tunnel.sessions;

  callback(null, Object.keys(sessions).map(function(id) {
    return sessions[id];
  }));

}


/**
 * Get a session
 *
 * @api public
 * @param {Session|{serverId: String, tunnelId: String, id: String}} session
 * @param {Function} callback
 *
 */

WebsocketTunnelController.prototype.getSession = function($happn, session, callback) {

  if (!session.serverId) return callback(new Error('missing session.serverId'));
  if (!session.tunnelId) return callback(new Error('missing session.tunnelId'));
  if (!session.id) return callback(new Error('missing session.id'));

  if (!this.servers[session.serverId]) return callback(new Error('no server with id ' + session.serverId));

  var server = this.servers[session.serverId];

  var tunnels = server.tunnels;

  if (!tunnels[session.tunnelId]) return callback(new Error('no tunnel with id ' + session.tunnelId));

  var tunnel = tunnels[session.tunnelId];

  var sessions = tunnel.sessions;

  if (!sessions[session.id]) return callback(new Error('no session with id ' + session.id));

  session = sessions[session.id];

  callback(null, session);

}


/**
 * Open tunnel (set world facing tcp server listening)
 *
 * @api public
 * @param {{serverId: String, id: String}} tunnel
 * @param {{port: Number, hostname: String}} address
 *
 */

WebsocketTunnelController.prototype.openTunnel = function($happn, tunnel, address, callback) {

  if (!tunnel.serverId) return callback(new Error('missing tunnel.serverId'));
  if (!tunnel.id) return callback(new Error('missing tunnel.id'));

  if (!this.servers[tunnel.serverId]) return callback(new Error('no server with id ' + tunnel.serverId));
  
  var server = this.servers[tunnel.serverId];

  var tunnels = server.tunnels;
  
  if (!tunnels[tunnel.id]) return callback(new Error('no tunnel with id ' + tunnel.id));

  tunnel = tunnels[tunnel.id];

  if (tunnel.state.value == 'open') {
    $happn.log.warn('opening already open tunnel');
    return callback(null, tunnel);
  }

  var tcpServer = tunnel.tcpServer;
  var forwardingHost = address.hostname || server.wsOpts.forwardingHostname;
  var forwardingPort = address.port || tunnel.defaultForwardingPort;

  tcpServer.once('error', function(e) {
    if (callback.used) {
      // Listen already succeeded...
      return;
    }

    server.wst.emit('tunnel/error', tunnel.id, e);

    callback(e);
    callback.used = true;
  });

  tcpServer.listen(forwardingPort, forwardingHost, function() {

    server.wst.emit('tunnel/open', tunnel.id, forwardingHost, forwardingPort);

    if (callback.used) {
      // callback alread ocurred in error, but the listen succeeded, tunnel is open.
      $happn.log.error('listen succeeded despite error');
      return; // don't do second callback
    }

    callback(null, tunnel);
    callback.used = true;

  });


}


/**
 * Close tunnel (set world facing tcp server to closed)
 *
 * @api public
 * @param {Tunnel|{serverId: String, id: String}} tunnel
 *
 */

WebsocketTunnelController.prototype.closeTunnel = function($happn, tunnel, callback) {

  if (!tunnel.serverId) return callback(new Error('missing tunnel.serverId'));
  if (!tunnel.id) return callback(new Error('missing tunnel.id'));

  if (!this.servers[tunnel.serverId]) return callback(new Error('no server with id ' + tunnel.serverId));
  
  var server = this.servers[tunnel.serverId];

  var tunnels = server.tunnels;
  
  if (!tunnels[tunnel.id]) return callback(new Error('no tunnel with id ' + tunnel.id));

  tunnel = tunnels[tunnel.id];


  if (tunnel.state.value == 'closed') {
    $happn.log.warn('closing already closed tunnel');
    return callback(null, tunnel);
  }

  // Each session needs to be destroyed so that the tcpServer.close() calls back
  // (otherwise existing session remain, some a websockets and may ramain a long time)

  Object.keys(tunnel.sessions).forEach(function(key) {

    var session = tunnel.sessions[key];
    var socket = session.socket;   // _world_ facing socket
    var carrier = session.carrier; // tunnel facing websocket
    
    socket.destroy();
    // carrier.destroy(); // TODO: ensure properly closed all the way to target (brain)

    // artificial destroy does not raise 'close' event that leads to 'session/destroy' event
    // so it needs to be done manually

    server.wst.emit('session/destroy', {id: session.id, tunnelId: tunnel.id, destroyedBy: 'closeTunnel'});

  });

  var tcpServer = tunnel.tcpServer;

  try {
    tcpServer.close(function() {
      server.wst.emit('tunnel/close', tunnel.id);
      callback(null, tunnel);
    });
  }
  catch (e) {
    // not listening

    // may lead to duplicate close events
    server.wst.emit('tunnel/close', tunnel.id);
    callback(null, tunnel);
  }

}


/**
 * Reset the tunnel by closing from the server side. Tunnel client will reconnect.
 *
 * @api public
 * @param {}
 * @param {Tunnel|{serverId: String, id: String}} tunnel
 *
 */

WebsocketTunnelController.prototype.resetTunnel = function($happn, tunnel, callback) {

  var _this = this;

  this.closeTunnel($happn, tunnel, function(e) {

    // ignore e

    if (!tunnel.serverId) return callback(new Error('missing tunnel.serverId'));
    if (!tunnel.id) return callback(new Error('missing tunnel.id'));

    if (!_this.servers[tunnel.serverId]) return callback(new Error('no server with id ' + tunnel.serverId));
    
    var server = _this.servers[tunnel.serverId];

    var tunnels = server.tunnels;
    
    if (!tunnels[tunnel.id]) return callback(new Error('no tunnel with id ' + tunnel.id));

    tunnel = tunnels[tunnel.id];

    tunnel.wsControl.socket.destroy();

    server.wst.emit('tunnel/reset', tunnel.id);

    callback(null, tunnel);

  });

};


/**
 * Initiate the client side of a tunneling pair.
 *
 * @api public
 * @param {ClientOptions} opts
 * @param {Function} callback
 *
 */

// TODO, callback AFTER started/connected (option)

WebsocketTunnelController.prototype.createClient = function($happn, opts, callback) {

  if (typeof opts == 'function') {
    callback = opts;
    opts = {};
  }

  opts.mode = opts.mode || 'reverse';
  opts.serial = 'pending_serial_no';
  opts.name = opts.name || $happn.info.mesh.name;
  opts.description = opts.description || '';
  opts.id = opts.id || shortid.generate();
  opts.ifaces = this.externalInterfaces().join(',');
  opts.hostname = os.hostname();
  opts.retryStartingInterval = opts.retryStartingInterval || 2000;
  opts.retryIntervalMultiplier = opts.retryIntervalMultiplier || 1.5;
  opts.retryIntervalMax = opts.retryIntervalMax || 60000;
  opts.healthInterval = opts.healthInterval || 10000;
  opts.healthReconnectTimeout = opts.healthReconnectTimeout || 60000;

  var address = $happn.info.datalayer.address;

  opts.forwardTo = opts.forwardTo || address.address + ':' + address.port;

  if (opts.mode !== 'reverse') { 
    return callback(new Error('Only reverse mode supported in tunnel client'));
  }

  $happn.log.$$DEBUG('start tunnel client', opts);

  var reverseClient = new wst.ClientReverse($happn.log);

  var client = new Client(opts, reverseClient);

  this.clients[client.id] = client;

  $happn.emit('client/create', client);

  reverseClient.start(opts, function(e, _) {

    callback(e, client);

  });

};

/**
 * Initiate multiple client sides for tunneling
 *
 * @api public
 * @param {Array} optsArray of ClientOptions
 * @param {Function} callback
 *
 */

WebsocketTunnelController.prototype.createClients = function($happn, optsArray, callback) {

  // TODO: similar issues to createServers()

  var _this = this;

  Promise.all(optsArray.map(function(opts) {

    return new Promise(function(resolve, reject) {

      _this.createClient($happn, opts, function(e, _) {

        if (e) return reject(e);

        return resolve();

      });

    });

  }))

  .then(function(_) {
    callback(null);
  })

  .catch(callback);

}


/**
 * Properly stop tunnel client
 *
 * @api public
 * @param {Function} callback
 *
 * Sends propper termination to remote clients (browsers) using the tunnel?
 * 
 */

WebsocketTunnelController.prototype.destroyClient = function($happn, opts, callback) {
  callback(new Error('not implemented'));
};


var ifaces;
WebsocketTunnelController.prototype.externalInterfaces = function(callback) {
  if (ifaces) {
    if (callback) callback(null, ifaces);
    return ifaces;
  }
  var ifacesList;
  var got = {};
  ifaces = [];
  Object.keys(ifacesList = os.networkInterfaces()).forEach(function(dev) {
    ifacesList[dev]
    .filter(function(address) {
      return address.internal == false && address.family == 'IPv4';
    })
    .forEach(function(iface) {
      if (got[iface.address]) return;
      ifaces.push(iface.address);
      got[iface.address] = 1;
    });
  });
  if (callback) callback(null, ifaces);
  return ifaces;
}



var loadTerminal = function($happn, tunnelController) {

  // quick hack for terminal access to selected functionalities

  if (terminalDone) return;
  if (!$happn.exchange.terminal) return;
  terminalDone = true;

  $happn.exchange.terminal.register($happn.name, {

    description: 'Manage tunnels.',

    autoComplete: function(args, callback) {

      if (args.length == 1) {
        return callback(null, [
          'openTunnel',
          'closeTunnel',
          'listSessions'
        ]);
      }

      // autocomplete for tunnel names, pending more useful mesh _NETWORK tree

      if (args.length == 2) {
        var tunnels = [];
        Object.keys(tunnelController.servers).map(function(id1) {
          var sname = tunnelController.servers[id1].name;
          Object.keys(tunnelController.servers[id1].tunnels).map(function(id2) {
            var tname = tunnelController.servers[id1].tunnels[id2].name;
            tunnels.push(sname + '/' + tname);
          });
        });
        return callback(null, tunnels);
      }

    },

    run: function(args, callback) {

      var action = args[0];
      var target = args[1];
      var port = args[2];

      if (action == 'openTunnel' || action == 'closeTunnel' || action == 'listSessions') {
        var parse = target.split('/');
        var serverName = parse[0];
        var tunnelName = parse[1];

        Object.keys(tunnelController.servers).forEach(function(id) {
          var server = tunnelController.servers[id];
          if (server.name != serverName) return;

          Object.keys(server.tunnels).forEach(function(id) {
            var tunnel = server.tunnels[id];
            if (tunnel.name != tunnelName) return;

            console.log();

            if (action == 'openTunnel') {

              tunnelController[action]($happn, {
                serverId: server.id,
                id: tunnel.id,
              }, {
                port: port ? parseInt(port) : null
              }, callback);


              callback._used = true;
              return;
            }

            tunnelController[action]($happn, {
              serverId: server.id,
              id: tunnel.id,
              port: port ? parseInt(port) : null
            }, callback);

            callback._used = true;

          });
        });

        if (!callback._used) {
          console.log('\nno such tunnel');
        }

        return;
      }

      if (!callback._used) callback(null);

    }



  }, function() {});

}
