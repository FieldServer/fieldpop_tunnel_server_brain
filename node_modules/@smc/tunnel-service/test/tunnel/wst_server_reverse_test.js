var stub = require('../stub');
// var toss = require('../toss');
var log = require('../log');
var should = new require('chai').should();
// var Promise = require('bluebird');
var request = require('request');
var http = require('http');

describe('tunnel/wst_server_reverse_test.js', function() {

  this.timeout(0);

  before(function() {

    this.wst = require('../../lib/tunnel/wst');

    this.$happn = {
      log: log
    }

  });

  afterEach(stub.restore);

  context('Events', function() {

    before(function(done) {

      // target port

      this.server = http.createServer(function(req, res) {res.end()});
      this.server.listen(8888, done);
    });

    after(function(done) {
      this.server.close(done);
    });

    before(function(done) {
      
      this.server_reverse = new this.wst.ServerReverse(this.$happn.log);
      this.server_reverse.start({wsport: 12345, startOpen: true}, done);

    });

    beforeEach(function() {

      this.clientOpts = {
        defaultForwardingPort: 00000,
        forwardingService: 'ws://localhost:12345',
        forwardTo: 'localhost:8888',
        // id: 'clientid',
        serial: 'serial',
        hostname: 'hostname',
        ifaces: '__IP__,__IP__',
        name: 'name',
        description: 'with\nnew\nlines\n',
        carrierWait: 10000,
        healthInterval: 1000,
        healthReconnectTimeout: 10000,
      }

    });


    it('emits "tunnel/create" when client requests', function(done) {

      this.server_reverse.once('tunnel/create', function(request) {
        done();
      });

      var wstClient = new this.wst.ClientReverse(this.$happn.log);

      this.clientOpts.id = 'client1';
      this.clientOpts.defaultForwardingPort = 6001;

      wstClient.start(this.clientOpts, function(e, _) {
        if (e) console.log(e);
      });

    });

    it('emits "tunnel/open" when opts.startOpen and open succeeds', function(done) {

      this.server_reverse.once('tunnel/open', function(request) {
        done();
      });

      var wstClient = new this.wst.ClientReverse(this.$happn.log);

      this.clientOpts.id = 'client1';
      this.clientOpts.defaultForwardingPort = 6004;

      wstClient.start(this.clientOpts, function(e, _) {
        if (e) console.log(e);
      });

    });

    xit('emits "tunnel/destroy" when tunnelClient disconnects', function(done) {

      // done()
      // not tested

    });

    xit('emits "tunnel/interrupt" when tunnelClient becomes unavailable', function(done) {


    });

    xit('emits "tunnel/resume" when tunnelClient becomes available agiain', function(done) {


    });

    it('emits "session/create" when _world_ requests tunnel', function(done) {

      var _this = this;

      var wstClient = new this.wst.ClientReverse(this.$happn.log);

      this.clientOpts.id = 'client2';
      this.clientOpts.defaultForwardingPort = 6002;

      wstClient.start(this.clientOpts, function(e, _) {
        if (e) done(e);

        _this.server_reverse.once('session/create', function(request) {
          done();
        });

        setTimeout(function() {
          request('http://localhost:6002/i');
        }, 50);

      });

    });


    context('emits "session/destroy" when _world_ session is closed', function() {

      it('websocket end');

      it('by http end', function(done) {

        var _this = this;

        stub(this.server_reverse, function genId() {
          return '__SESSION_ID__';
        });

        var server = http.createServer(function(req, res) {

          _this.server_reverse.once('session/destroy', function(end) {

            end.should.eql({
              destroyedBy: 'tcpConn.end',
              id: '__SESSION_ID__',
              tunnelId: 'client3',
            });
            done();
          });

          res.end();
        });

        server.listen(8889, function() {

          var wstClient = new _this.wst.ClientReverse(_this.$happn.log);

          _this.clientOpts.id = 'client3';
          _this.clientOpts.defaultForwardingPort = 6003;
          _this.clientOpts.forwardTo = 'localhost:8889';

          wstClient.start(_this.clientOpts, function(e, _) {

            setTimeout(function() {
              request('http://localhost:6003/i', function(e) {
              });
            }, 50);

          });

        });

      });

    });

    xit('emits "session/fail" and errors the _world_ socket when target could not be reached', function(done) {

      // done();
      // not tested

    });

  });

});
