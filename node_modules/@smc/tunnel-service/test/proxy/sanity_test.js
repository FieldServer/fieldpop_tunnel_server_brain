var normalize = require('path').normalize;

module.exports = SocketSanityTest;

function SocketSanityTest() {}

SocketSanityTest.prototype.start = function($happn, opts, callback){
  callback();
}

SocketSanityTest.prototype.sharedEventMethod = function($happn, opts, callback) {
  opts.meshName = $happn.info.mesh.name;
  $happn.log.info('sharedEventMethod');
  $happn.emit('sanity-test-shared-event-ran/' + opts.n, opts);
  callback(null, opts);
}

SocketSanityTest.prototype.sharedMethod = function($happn, opts, callback) {
  callback(null, opts);
}

SocketSanityTest.prototype.webMethod = function($happn, req, res) {
  res.end(req.url);
}

if (global.TESTING_SOCKETSANITY) return; 

var proxyServerOpts = {
  tunnelComponentName:'websocket-tunnel',
  listenPort:9090,
}

var tunnelServerOpts = {

  name: 'tunnel-server-one',

  description: 'created at startup',

  wsport: 10000,

  wshostname: 'localhost',

  forwardingHostname: '0.0.0.0',

  startOpen: true,  //process.env.START_OPEN == '1',

  healthInterval: 5000,

  emits: {
    'server/create': true,
    'tunnel/create': true,
    'tunnel/open': true,
    'tunnel/close': true,
    'tunnel/error': true,
    'tunnel/health': true,
    'tunnel/destroy': true,
    'tunnel/reset': true,
    'session/create': true,
    'session/establish': true,
    'session/destroy': true,
    'session/fail': true,
  }
}

var tunnelClientOpts = {
  
  name: 'tunnel-sanity-test',
  description: 'description at leaf',
  defaultForwardingPort: 0,  // <--------------- 0 == server assigns next free port
  forwardingService: 'ws://localhost:10000',
  healthInterval: 1000

}

var cloudMesh = {

  name: 'cloud-mesh',
  port: 8080,

  modules: {
    'websocket-tunnel': {
      path: normalize(__dirname + '../../../'),
    }
  },

  components: {
    'websocket-tunnel': {
      moduleName: 'websocket-tunnel',
      startMethod: 'createServer',
      schema: {
        methods: {
          'createServer': {
            parameters: [
              { name: 'opts', value: tunnelServerOpts }
            ]
          }
        }
      },
      web:{
        routes:{
          "static":"dashboard"
        }
      }
    }
  }
};

var leafMeshConfig = function(name, port) {

  return {

    name: name,
    port: port,

    modules: {

      'websocket-tunnel': {     
        path: normalize(__dirname + '../../../')
      },

      'SocketSanityTest': {
        path: __filename
      }      

    },

    components: {

      'websocket-tunnel': {
        moduleName: 'websocket-tunnel',
        startMethod: 'createClient',
        schema: {
          methods: {
            'createClient': {
              parameters: [
                {name: 'opts', value: tunnelClientOpts}
              ]
            }
          }
        }
      },

      'SocketSanityTest': {
        startMethod: 'start',
        schema: {
          exclusive: false,
          methods: {
            'start': {
              parameters: [
                {name: 'opts', value: {}}
              ]
            }
          }
        },
        web: {
          routes: {
            webMethod: 'webMethod'
          }
        }
      }
    }
  }
};

var should = require('chai').should();
var mesh;
var Mesh = require('happner');
var request = require('request');
var once = require('once');

context('leaf-mesh started', function() {

  this.timeout(0);

  before(function(done) {
    var _this = this;
    Mesh.create(leafMeshConfig('leaf-mesh', 8090)).then(function(mesh) {
      _this.leafMesh = mesh;
      done();
    }).catch(done);
  });

  after(function(done) {
    this.leafMesh.stop(done);
  });

  before(function() {
    global.TESTING_SOCKETSANITY = true; //.............
  });

  after(function() {
    delete global.TESTING_SOCKETSANITY;
  });



  it('can access the leaf-mesh directly, using the happner client', function(done) {

    var MeshClient = require('happner/lib/system/api');

    new MeshClient('localhost', 8090, 'mesh', function(err, client) {

      if (err) return done(err);

      client.exchange.SocketSanityTest.sharedMethod({'tested-shared':true}, function(e, result){

        if (e) return done(e);
        result['tested-shared'].should.equal(true);

        client.event.SocketSanityTest.on('sanity-test-shared-event-ran/1', function(result){
          done();
        });

        client.exchange.SocketSanityTest.sharedEventMethod({n: 1}, function(e, result){
           if (e) return done(e);
        });

      });

    });

  });


  context('cloud-mesh started', function(done) {

    before(function(done) {
      var _this = this;

      done = once(done); // a later test casues tunnel/create to be emitted again
                        // make done only once

      Mesh.create(cloudMesh).then(function(mesh) {
        _this.cloudMesh = mesh;

        mesh.event['websocket-tunnel'].on('tunnel/open', function(tunnel) {
          _this.tunnel = tunnel;
          done();
        });

      }).catch(done);
    });

    after(function(done) {
      this.cloudMesh.stop(done);
    });


    it('can access the leaf-mesh mesh through the tunnel, using the happner client', function(done) {

      var MeshClient = require('happner/lib/system/api');

      var hostname = this.tunnel.forwarding.address;
      var port = this.tunnel.forwarding.port;

      new MeshClient(hostname, port, 'mesh', function(err, client) {

        if (err) return done(err);

        client.exchange.SocketSanityTest.sharedMethod({'tested-shared':true}, function(e, result){

          if (e) return done(e);
          result['tested-shared'].should.equal(true);

          client.event.SocketSanityTest.on('sanity-test-shared-event-ran/2', function(result){
            done();
          });

          client.exchange.SocketSanityTest.sharedEventMethod({n: 2}, function(e, result){
             if (e) return done(e);
          });

        });

      });

    });

    context('insert tunnel-proxy component into cloud-mesh', function() {

      before(function() {
        this.hostname = this.tunnel.id.toLowerCase() + '.127.0.0.1.xip.io';
      });

      before('insert tunnel-proxy', function(done) {

        this.cloudMesh._createElement({
          module: {
            name: 'tunnel-proxy',
            config: {
              instance: require(normalize(__dirname + '../../../')).Proxy
            }
          },
          component: {
            name: 'tunnel-proxy',
            config: {
              startMethod: 'initialize',
              schema: {
                methods: {
                  'initialize': {
                    parameters: [
                      { name: 'opts', value: proxyServerOpts }
                    ]
                  }
                }
              }
            }
          }
        }).then(done).catch(done);

      });

      it('can access the client mesh through the tunnel and the proxy, with a regular http request', function(done) {

        var _this = this;

        var hostname = this.tunnel.id.toLowerCase() + '.127.0.0.1.xip.io';

        request('http://' + hostname + ':9090/SocketSanityTest/webMethod/deeper?more=1', function(e, response) {

          if (e) {

            console.log('Error', e)
            console.log('Hostname:', _this.hostname);
            done(e);

          }

          response.statusCode.should.equal(200);
          response.body.should.equal('/deeper?more=1');
          done();

        });

      });


      it('can access the client mesh through the tunnel and the proxy, with a websocket', function(done) {

        var hostname = this.tunnel.id.toLowerCase() + '.127.0.0.1.xip.io';

        var MeshClient = require('happner/lib/system/api');

        new MeshClient(hostname, 9090, 'mesh', function(err, client) {

          if (err) return done(err);

          client.exchange.SocketSanityTest.sharedMethod({'tested-shared':true}, function(e, result){

            if (e) return done(e);
            result['tested-shared'].should.equal(true);

            client.event.SocketSanityTest.on('sanity-test-shared-event-ran/3', function(result){
              done();
            })

            client.exchange.SocketSanityTest.sharedEventMethod({n: 3}, function(e, result){
               if (e) return done(e);
            });

          });

        });

      });

      context('create another leaf and tunnel to it to confirm the proxy get updated', function() {

        before(function(done) {
          
          var _this = this;

          this.cloudMesh.event['tunnel-proxy'].on('route/create', function(route) {
            _this.newRoute = route;
            done()
          });

          // same objeject being used as second tunnel client config
          // will not fefault connectly beceuase of defaults from previous tunne;client
          // delete them
          delete tunnelClientOpts.id;
          delete tunnelClientOpts.forwardTo;

          Mesh.create(leafMeshConfig('another-leaf-mesh', 8091)).then(function(mesh) {
            _this.anotherLeafMesh = mesh;
          }).catch(done);
        });

        it('use new leaf across tunnel', function(done) {

          var MeshClient = require('happner/lib/system/api');

          var hostname = this.newRoute.hostref + '.127.0.0.1.xip.io';

          MeshClient(hostname, 9090, 'mesh', function(err, client) {

            client.event.SocketSanityTest.on('sanity-test-shared-event-ran/4', function(result) {

              result.meshName.should.equal('another-leaf-mesh');
              done();

            });

            client.exchange.SocketSanityTest.sharedEventMethod({n: 4}, function(e, result){
               if (e) return done(e);
            });

          });

        });

      });

    });

  });

});
