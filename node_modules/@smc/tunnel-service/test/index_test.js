var WebsocketTunnelController = require('../lib/index');

var stub = require('./stub');
var toss = require('./toss');
var log = require('./log');
var should = new require('chai').should();
var Promise = require('bluebird');
var shortid = require('shortid');
var os = require('os');
var request = require('request');
var http = require('http');

describe('index.js', function() {

  this.timeout(0)

  afterEach(stub.restore);

  before(function() {

    this.wst = require('../lib/tunnel/wst');

    this.$happn = {
      emit: function() {},
      exchange: {
      },
      log: log,
      info: {
        mesh: {
          name: 'meshname'
        },
        datalayer: {
          address: {
            address: '10.0.0.9', // <---------- mock datalayer address
            port: 55001,
          }
        }
      }
    }

  });

  beforeEach(function() {
    stub(shortid, function generate() {
      return '__ID__';
    });
    stub(os, function hostname() {
      return '__HOSTNAME__';
    });
    stub(Date, function now() {
      return '__TIMESTAMP__';
    });
  });


  it('uses the brain serial number');

  it('can map clients per serial/id/datalayer_network to (tunnel entrance) ports');

  it('maintinans a pool of ws-carrier connections');

  it('proxies to correct tunnel per url in http header');

  context('createServer()', function() {

    xit('tunnel creation ws url can be secured', function() {

      // not "anyone can create a tunnel"

    });

    it('can use happner connection as control channel that initializes the ws-carriers', function() {

      // Allows for happn/happner authentication to have already occurred.
      // Requires either tunneledTo client (brain) to have endpoint to cloud or vice versa

    });

    it('defaults to create 1 reverse tunnel server on ws port 10000 with datalayer address', function(done) {

      var _this = this;

      var t = new WebsocketTunnelController();

      var calls = stub(this.wst.ServerReverse.prototype, function start(opts, callback) {

        opts.should.eql({
          startOpen: true,
          forwardingHostname: '0.0.0.0',
          wshostname: '10.0.0.9',
          wsport: 10000,
          carrierWait: 10000,
          healthInterval: undefined,
        });

        callback(null, 'URL');

      });

      t.createServer(this.$happn, function(e) {

        calls.count.should.equal(1);
        done();

      });

    });

    it('can create 1 reverse tunnel server on specified ws port with datalayer address', function(done) {

      var _this = this;

      var t = new WebsocketTunnelController();

      var calls = stub(this.wst.ServerReverse.prototype, function start(opts, callback) {

        opts.should.eql({
          startOpen: true,
          forwardingHostname: '0.0.0.0',
          wshostname: '10.0.0.9',
          wsport: 5566,
          carrierWait: 10000,
          healthInterval: undefined,
        });

        callback(null, 'URL');

      });

      t.createServer(this.$happn, {wsport: 5566}, function(e) {

        calls.count.should.equal(1);
        done();

      });

    });

    it('can default ws hostname and ws port from env variables', function(done) {

      process.env.WS_SERVER_PORT = 44444;
      process.env.WS_SERVER_HOSTNAME = 'localhost';

      // force require reload 

      delete require.cache[require.resolve('../lib/index')];
      WebsocketTunnelController = require('../lib/index');

      var _this = this;

      var t = new WebsocketTunnelController();

      var calls = stub(this.wst.ServerReverse.prototype, function start(opts, callback) {

        opts.should.eql({
          startOpen: true,
          forwardingHostname: '0.0.0.0',
          wshostname: 'localhost',
          wsport: 44444,
          carrierWait: 10000,
          healthInterval: undefined,
        });

        callback(null, 'URL');

      });

      t.createServer(this.$happn, {wsport: 5567}, function(e) {

        calls.count.should.equal(1);


        // restore original

        delete process.env.WS_SERVER_PORT;
        delete process.env.WS_SERVER_HOSTNAME;
        delete require.cache[require.resolve('../lib/index')];
        WebsocketTunnelController = require('../lib/index');

        done();

      });

    })

    it('calls back with the new server upon listening', function(done) {

      var url, listened = false;

      var t = new WebsocketTunnelController();

      var http = require('http');

      var calls = stub(http, function createServer(handler) {

        return mockHttpServer = {

          on: function() {},

          address: function() {

            return { address: '127.0.0.1', family: 'IPv4', port: 5567 };

          },

          listen: function(hostname, port, callback) {

            listened = true;
            callback();

          }

        };

      });

      t.createServer(this.$happn, {wsport: 5567}, function(e, server) {

        listened.should.equal(true);
        calls.count.should.equal(1);
        server.should.eql({
          id: '10.0.0.9:5567',
          // tunnels: {},
          created: '__TIMESTAMP__',
          description: '',
          mode: 'reverse',
          name: 'meshname',
          url: 'http://127.0.0.1:5567',
          wsOpts: {
            carrierWait: 10000,
            startOpen: true,
            forwardingHostname: '0.0.0.0',
            wshostname: '10.0.0.9',
            wsport: 5567,
            healthInterval: undefined,
          }
        });
        done();

      });

    });


    it('adds a server to the collection with default name/description and the wst server', function(done) {

      // UI presents all the tunnel servers running in the mesh node
      // each tunnel can have a name for easy ident, (versus proto://ip:port, which is the internal collection key)
      // and a description for operator recollection assistance

      var t = new WebsocketTunnelController();

      var serverOpts = {
        wshostname: 'localhost',
        wsport: 4455
      };

      t.createServer(this.$happn, serverOpts, function(e) {

        // Enumerates without wst,

        t.servers['localhost:4455'].should.eql({
          // tunnels: {},
          id: 'localhost:4455',
          created: '__TIMESTAMP__',
          name: 'meshname',
          description: '',
          mode: 'reverse',
          url: 'http://127.0.0.1:4455',
          wsOpts: {
            carrierWait: 10000,
            startOpen: true,
            forwardingHostname: '0.0.0.0',
            wshostname: 'localhost',
            wsport: 4455,
            healthInterval: undefined,
          }
        });

        // Has wst property (the websocket tunnel server instance)

        should.exist(t.servers['localhost:4455'].wst);

        done();

      });

    });

    context('events:', function() {

      context('server/create', function() {

        it('is emitted when a new server is created', function(done) {

          var t = new WebsocketTunnelController();

          var calls = stub(this.$happn, function emit(path, data) {

            path.should.equal('server/create');

            data.should.eql({
              // tunnels: {},
              id: 'localhost:5569',
              created: '__TIMESTAMP__',
              name: 'meshname',
              description: '',
              mode: 'reverse',
              url: 'http://127.0.0.1:5569',
              wsOpts: {
                carrierWait: 10000,
                startOpen: true,
                forwardingHostname: '0.0.0.0',
                wshostname: 'localhost',
                wsport: 5569,
                healthInterval: undefined,
              }
            });

          });

          var serverOpts = {
            wshostname: 'localhost',
            wsport: 5569
          };

          t.createServer(this.$happn, serverOpts, function(e) {

            calls.count.should.equal(1);
            done();

          });

        });

      });


      context('tunnel/create', function() {

        it('is emitted when a client requests at the server to create a tunnel', function(done) {

          var serverController = new WebsocketTunnelController();
          var clientController = new WebsocketTunnelController();
          var _this = this;

          var callsDate = stub(Date, function now() {
            return 'TIMESTAMP';
          });

          var serverOpts = {
            id: 'SERVER_ID',
            wshostname: 'localhost',
            wsport: 5570
          };

          serverController.createServer(this.$happn, serverOpts, function(e) {

            stub(_this.$happn, function emit(path, data) {

              if (path == 'client/create') return; // ignore clientside event (same $happn instance)

              path.should.equal('tunnel/create');

              data.id.should.equal('__ID__');
              data.name.should.equal('NAME');
              data.serverId.should.equal('SERVER_ID');
              data.state.should.eql({
                timestamp: 'TIMESTAMP',
                value: 'closed' // tunnel is created closed, it may proceed immediately to open
              });
              data.serial.should.equal('pending_serial_no');

              should.exist(data.wsControl);
              should.exist(data.tcpServer);

              done();

            });

            clientController.createClient(_this.$happn, {

              name: 'NAME',
              defaultForwardingPort: 3333,
              forwardingService: 'ws://localhost:5570',

            }, function() {

            });

          });

        });

      });

      context('tunnel/open', function() {

        it('is emitted when tunnel is opened by startOpen=true', function(done) {

          var serverController = new WebsocketTunnelController();
          var clientController = new WebsocketTunnelController();
          var _this = this;

          var callsDate = stub(Date, function now() {
            return 'TIMESTAMP';
          });

          var serverOpts = {
            startOpen: true,
            id: 'SERVER_ID',
            wshostname: 'localhost',
            wsport: 5573
          };

          serverController.createServer(this.$happn, serverOpts, function(e) {

            stub(_this.$happn, function emit(path, data) {

              if (path == 'client/create') return; // ignore clientside event (same $happn instance)
              if (path == 'tunnel/create') return;

              path.should.equal('tunnel/open');

              data.state.value.should.equal('open');
              data.state.timestamp.should.equal('TIMESTAMP');
              data.forwarding.should.eql({
                address: '0.0.0.0',
                family: 'IPv4',
                port: 3336
              });

              done();

            });

            clientController.createClient(_this.$happn, {

              name: 'NAME',
              defaultForwardingPort: 3336,
              forwardingService: 'ws://localhost:5573',

            }, function() {

            });

          });

        });

        it('is emitted when tunnel is opened by call to openTunnel', function(done) {

          var serverController = new WebsocketTunnelController();
          var clientController = new WebsocketTunnelController();
          var _this = this;

          var callsDate = stub(Date, function now() {
            return 'TIMESTAMP';
          });

          var serverOpts = {
            startOpen: false,  // <----------- start without opening tunnel
            id: 'SERVER_ID',
            wshostname: 'localhost',
            wsport: 5574,
          };

          serverController.createServer(this.$happn, serverOpts, function(e, server) {

            stub(_this.$happn, function emit(path, data) {

              if (path == 'client/create') return;
              if (path == 'tunnel/create') return;

              path.should.equal('tunnel/open');

              data.state.value.should.equal('open');
              data.state.timestamp.should.equal('TIMESTAMP');
              data.forwarding.should.eql({
                address: '0.0.0.0',
                family: 'IPv4',
                port: 3337
              });

              done();

            });

            clientController.createClient(_this.$happn, {

              name: 'NAME',
              defaultForwardingPort: 3337,
              forwardingService: 'ws://localhost:5574',

            }, function(e, client) {

              setTimeout(function() {

                var tunnel = {
                  serverId: server.id,
                  id: client.id,
                }

                var address = {
                  // hostname: '0.0.0.0',
                  port: 3337
                }

                serverController.openTunnel(_this.$happn, tunnel, address, function(e, tunnel) {

                  // console.log(e, tunnel);

                });

              }, 50); // <--------- wait for server to create the tunnel

            });

          });

        });

      });

      context('tunnel/close', function() {

        it('is emitted when tunnel is closed', function(done) {

          var serverController = new WebsocketTunnelController();
          var clientController = new WebsocketTunnelController();
          var _this = this;
          var i = 0;

          var callsDate = stub(Date, function now() {
            return 'TIMESTAMP';
          });

          var serverOpts = {
            startOpen: true,
            id: 'SERVER_ID',
            wshostname: 'localhost',
            wsport: 5576,
          };

          serverController.createServer(this.$happn, serverOpts, function(e, server) {

            stub(_this.$happn, function emit(path, data) {

              if (path == 'client/create') return;
              if (path == 'tunnel/create') return;
              if (path == 'tunnel/open') return;

              path.should.equal('tunnel/close');

              data.state.value.should.equal('closed');
              data.state.timestamp.should.equal('TIMESTAMP');
              // data.forwarding.should.eql({
              //   address: '0.0.0.0',
              //   family: 'IPv4',
              //   port: 3338
              // });

              done();

            });

            clientController.createClient(_this.$happn, {

              name: 'NAME',
              defaultForwardingPort: 3338,
              forwardingService: 'ws://localhost:5576',

            }, function(e, client) {

              setTimeout(function() {

                serverController.closeTunnel(_this.$happn, {
                  serverId: server.id,
                  id: client.id,
                }, function(e, tunnel) {

                  // console.log(e, tunnel);

                });

              }, 50); // <--------- wait for server to create the tunnel

            });

          });

        });

      });

      context('tunnel/destroy', function() {

        it('is emitted when tunnel client disconnects normally and remove tunnel from collection', function(done) {

          done();
          // not tested

        });

      });

      context('tunnel/interrupt', function() {

        // websocket control channel to tunnelClient is interrupted (network)

        xit('close tunnel "entrance" while target is unavailable??', function(done) {

        });

      });

      context('tunnel/resume', function() {

        // websocket control channel to tunnelClient is reconnected

        xit('open tunnel "entrance" that was closed for the interruption', function(done) {

        });

      });

      context('tunnel/error', function() {

        it('is emitted if tunnel failed to open/listen', function(done) {

          var serverController = new WebsocketTunnelController();
          var clientController = new WebsocketTunnelController();
          var _this = this;
          var i = 0;

          var callsDate = stub(Date, function now() {
            return 'TIMESTAMP';
          });

          var serverOpts = {
            startOpen: false,
            id: 'SERVER_ID',
            wshostname: 'localhost',
            wsport: 5575,
          };

          serverController.createServer(this.$happn, serverOpts, function(e, server) {

            stub(_this.$happn, function emit(path, data) {

              if (path == 'client/create') return;
              if (path == 'tunnel/create') return;

              path.should.equal('tunnel/error');

              data.state.value.should.equal('error');
              data.state.timestamp.should.equal('TIMESTAMP');
              data.state.error.message.should.equal('listen EACCES');

              done();

            });

            clientController.createClient(_this.$happn, {

              name: 'NAME',
              forwardingService: 'ws://localhost:5575',

            }, function(e, client) {

              setTimeout(function() {

                serverController.openTunnel(_this.$happn, {
                  serverId: server.id,
                  id: client.id
                }, {
                  port: 80 // <------------------------- not allowed
                }, function(e, tunnel) {

                  // console.log(e, tunnel);

                });

              }, 50);

            });

          });

        });

      });

      context('session/create', function() {

        it('is emitted (if enabled) when a new session is initiated across the tunnel', function(done) {

          var serverController = new WebsocketTunnelController();
          var clientController = new WebsocketTunnelController();
          var _this = this;

          var serverOpts = {
            id: 'SERVER_ID',
            wshostname: 'localhost',
            wsport: 5571,
            startOpen: true,
            emits: {
              'session/create': true // default is false
            }
          }

          serverController.createServer(this.$happn, serverOpts, function(e) {

            clientController.createClient(_this.$happn, {

              name: 'NAME',
              defaultForwardingPort: 3334,
              forwardingService: 'ws://localhost:5571',

            }, function() {

              stub(_this.$happn, function emit(path, data) {

                if (path == 'tunnel/create') return;

                path.should.equal('session/create');

                done();

              });

              // client down not wait for listen before callback
              // it is probably not listening yet...

              setTimeout(function() {

                // create new session by requesting onto the forwardingPort

                request('http://localhost:3334/moo/oink/sqweel/woof/chirp/purr/growl/buzz/beep/tweet?hello=1',
                  function(e, response) {
                    // console.log('EE', e, 'RR', response);
                  }
                )

              }, 50);

            });

          });

        });

      });

      context('session/destroy', function() {

        before(function(done) {
          this.httpServer = http.createServer(function(req, res) {
            res.end();
          });
          this.httpServer.listen(8887, done);
        });


        // // not done work to terminte all sessions so that close calls back
        // after(function(done) {
        //   this.httpServer.close(done);
        // })

        it('is emitted (if enabled) when a session ends', function(done) {

          var serverController = new WebsocketTunnelController();
          var clientController = new WebsocketTunnelController();
          var _this = this;

          var serverOpts = {
            id: 'SERVER_ID',
            wshostname: 'localhost',
            wsport: 5572,
            startOpen: true,
            emits: {
              'session/destroy': true // default is false
            }
          }

          serverController.createServer(this.$happn, serverOpts, function(e) {

            clientController.createClient(_this.$happn, {

              name: 'NAME',
              defaultForwardingPort: 3335,
              forwardingService: 'ws://localhost:5572',
              forwardTo: 'localhost:8887',

            }, function() {

              stub(_this.$happn, function emit(path, data) {

                if (path == 'tunnel/create') return;

                path.should.equal('session/destroy');

                done();

              });

              // client down not wait for listen before callback
              // it is probably not listening yet...

              setTimeout(function() {



                // create new session by requesting onto the forwardingPort

                request('http://localhost:3335/moo/oink/sqweel/woof/chirp/purr/growl/buzz/beep/tweet?hello=1',
                  function(e, response) {
                    // console.log('EE', e, 'RR', response);
                  }
                )

              }, 50);

            });

          });

        });

      });

    });

  });

  context('createServers()', function() {

    xit('can be provided /a/data/path in config to fetch an array of tunnel definitions to init', function(done) {

    });

    it('calls createServer() with each in the arrray of opts', function(done) {

      var t = new WebsocketTunnelController();

      var started = {};

      var calls = stub(t, function createServer($happn, opts, callback) {
        // console.log('opts', arguments);
        callback();
      });

      var optsArray = [
        {
          name: 'tun-svr-oem1-pri',
          description: 'oem one tunnel server (primary)',
          wsport: 40000,
          wshostname: 'localhost',
        },
        {
          name: 'tun-svr-oem1-sec1',
          description: 'oem one tunnel server (secondary 1)',
          wsport: 40001,
          wshostname: 'localhost',
        },
        {
          name: 'tun-svr-oem1-sec2',
          description: 'oem one tunnel server (secondary 2)',
          wsport: 40002,
          wshostname: 'localhost',
        },
      ];

      t.createServers(this.$happn, optsArray, function(e, url) {

        calls().count.should.equal(3);
        done();

      });

    });

  });


  context('listServers() and getServer()', function() {

    before('Create Multiple Servers', function(done) {

      this.t = new WebsocketTunnelController();

      var _this = this;

      this.t.createServers(this.$happn, [

        {
          name: 'tun-svr-oem1-pri',
          description: 'oem one tunnel server (primary)',
          wsport: 40000,
          wshostname: 'localhost',
        },
        {
          name: 'tun-svr-oem1-sec1',
          description: 'oem one tunnel server (secondary 1)',
          wsport: 40001,
          wshostname: 'localhost',
        },
        {
          name: 'tun-svr-oem1-sec2',
          description: 'oem one tunnel server (secondary 2)',
          wsport: 40002,
          wshostname: 'localhost',
        },

      ], function(e) {

        if (e) return done(e);

        done();

      });

    });


    it('lists all present tunnel servers or gets server', function(done) {

      var _this = this;

      this.t.listServers(this.$happn, function(e, servers) {

        servers[0].should.eql({
          id: 'localhost:40000',
          created: '__TIMESTAMP__',
          description: 'oem one tunnel server (primary)',
          mode: 'reverse',
          name: 'tun-svr-oem1-pri',
          url: 'http://127.0.0.1:40000',
          wsOpts: {
            carrierWait: 10000,
            startOpen: true,
            forwardingHostname: '0.0.0.0',
            wshostname: 'localhost',
            wsport: 40000,
            healthInterval: undefined,
          },
          // tunnels: {},
        });

        servers[1].id.should.equal('localhost:40001');
        servers[2].id.should.equal('localhost:40002');
        

        _this.t.getServer(_this.$happn, {id: 'localhost:40001'}, function(e, server) {

          server.id.should.equal('localhost:40001');
          done();

        });

      });

    });

    context('each listed server...', function() {

      before('Attach Multiple Clients', function(done) {

        // Depends on 'Create Multiple Servers' above

        var t = new WebsocketTunnelController();

        var i = 1;

        var id = 0;

        stub(shortid, function generate() {
          return id++;
        });

        Promise.promisifyAll(t);

        Promise.all([

          // Attach 3 to http://127.0.0.1:40000

          t.createClientAsync(this.$happn, {
            defaultForwardingPort: 4000 + i++,
            forwardingService: 'http://127.0.0.1:40000',
            forwardTo: 'localhost:' + 55000
          }),

          t.createClientAsync(this.$happn, {
            defaultForwardingPort: 4000 + i++,
            forwardingService: 'http://127.0.0.1:40000',
            forwardTo: 'localhost:' + 55000
          }),

          t.createClientAsync(this.$happn, {
            defaultForwardingPort: 4000 + i++,
            forwardingService: 'http://127.0.0.1:40000',
            forwardTo: 'localhost:' + 55000
          }),

          // 1 each to http://127.0.0.1:40001 and http://127.0.0.1:40002

          t.createClientAsync(this.$happn, {
            defaultForwardingPort: 4000 + i++,
            forwardingService: 'http://127.0.0.1:40001',
            forwardTo: 'localhost:' + 55000
          }),

          t.createClientAsync(this.$happn, {
            defaultForwardingPort: 4000 + i++,
            forwardingService: 'http://127.0.0.1:40002',
            forwardTo: 'localhost:' + 55000
          }),

        ])

        .then(toss(done)).catch(done);

      });

      it('contains attached tunnels', function(done) {

        Object.keys(this.t.servers['localhost:40000'].tunnels).length.should.equal(3);
        Object.keys(this.t.servers['localhost:40001'].tunnels).length.should.equal(1);
        Object.keys(this.t.servers['localhost:40002'].tunnels).length.should.equal(1);
        done();

      });

    });

  });

  context('getServer(id)', function() {

    it('gets the server');

  });

  context('getTunnel(serverId, tunnelId)', function() {

    it('gets one of the servers clients (tunnel)');

  });

  context('destroyServer(id)', function() {

    it('destroys the tunnel server');

  });

  context('createClient()', function() {

    it('creates an instance of a wst.ClientReverse with specified options', function(done) {

      var t = new WebsocketTunnelController();

      var opts = {
        name: 'moo',
        description: 'mooo',
        defaultForwardingPort: 8081,
        forwardingService: 'ws://localhost:10000',
        forwardTo: 'localhost:55000',
        retryIntervalMax: 100000,
        retryIntervalMultiplier: 1.1,
        retryStartingInterval: 1000,
        healthInterval: 2000,
        healthReconnectTimeout: 3000,


      };

      stub(WebsocketTunnelController.prototype, function externalInterfaces() {
        return ['__IP__','__IP__'];
      });

      var calls = stub(this.wst.ClientReverse.prototype,

        function start(opts, callback) {

          opts.should.eql({
            serial: 'pending_serial_no',
            name: 'moo',
            description: 'mooo',
            defaultForwardingPort: 8081,
            hostname: '__HOSTNAME__',
            ifaces: '__IP__,__IP__',
            id: '__ID__',
            forwardingService: 'ws://localhost:10000',
            forwardTo: 'localhost:55000',
            mode: 'reverse',
            retryIntervalMax: 100000,
            retryIntervalMultiplier: 1.1,
            retryStartingInterval: 1000,
            healthInterval: 2000,
            healthReconnectTimeout: 3000,

          });

          callback();
        }
      );

      t.createClient(this.$happn, opts, function(e, _) {
        
        calls.count.should.equal(1);
        done(e);

      });

    });


    context('client options', function() {

      beforeEach(function() {
        this.opts = {
          defaultForwardingPort: 8081,
          forwardingService: 'ws://localhost:10000',
          forwardTo: 'localhost:55000',
        };
      });

      it('accepts name and description', function(done) {

        var t = new WebsocketTunnelController();

        stub(WebsocketTunnelController.prototype, function externalInterfaces() {
          return ['__IP__','__IP__'];
        });

        var calls = stub(this.wst.ClientReverse.prototype,

          function start(opts, callback) {

            opts.name.should.equal('name');
            opts.description.should.equal('description');

            callback();
          }
        );

        this.opts.name = 'name';
        this.opts.description = 'description';

        t.createClient(this.$happn, this.opts, function(e, _) {
          calls.count.should.equal(1);
          done(e);
        });

      });

      it('defaults forwardTo to local datalayer', function(done) {

        var t = new WebsocketTunnelController();

        stub(WebsocketTunnelController.prototype, function externalInterfaces() {
          return ['__IP__','__IP__'];
        });

        var calls = stub(this.wst.ClientReverse.prototype,

          function start(opts, callback) {

            opts.forwardTo.should.equal('10.0.0.9:55001');

            callback();
          }
        );

        delete this.opts.forwardTo;

        t.createClient(this.$happn, this.opts, function(e, _) {
          calls.count.should.equal(1);
          done(e);
        });

      });

    });

  });

  context('createClients()', function() {

    xit('can be provided /a/data/path in config to fetch an array of tunnel definitions to init', function(done) {

    });

    it('calls createClient() with each in the arrray of opts', function(done) {

      var t = new WebsocketTunnelController();

      var calls = stub(t, function createClient($happn, opts, callback) {

        callback();

      });

      // eg. each server in a load balanced farm requires a tunnel to this node

      var optsArray = [
        {
          defaultForwardingPort: 8081,
          forwardingService: 'ws://server1.roundrobbin1.farm.cloud.com:10000',
          forwardTo: 'localhost:55000',
        },
        {
          defaultForwardingPort: 8081,
          forwardingService: 'ws://server2.roundrobbin1.farm.cloud.com:10000',
          forwardTo: 'localhost:55000',
        },
        {
          defaultForwardingPort: 8081,
          forwardingService: 'ws://serverN.roundrobbin1.farm.cloud.com:10000',
          forwardTo: 'localhost:55000',
        },
      ];

      t.createClients(this.$happn, optsArray, function(e, _) {

        calls.count.should.equal(3);
        done();

      });

    });

  });

  context('listClients()', function() {

    it('lists all present tunnel clients (clientside clients)');

    context('each listed client...', function() {

      it('contains state (connecting, connected, interrupted)');

    });

  });

  context('getClient(id)', function() {

    it('gets clientside client');

  });

  context('destroyClient()', function() {

    it();

  });

});
