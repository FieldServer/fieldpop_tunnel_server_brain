module.exports = TunnelProxy;

var Proxy = require('./lib/proxy');
var Promise = require('bluebird');


var bouncy = require('bouncy');
var util = require('util');



function TunnelProxy() {
  this.routes = {};
}

/**
 * Start
 *
 * @api public
 * @param {{listenPort: Number, tunnelComponentName: String}} opts
 * @param {Function} callback
 *
 */

TunnelProxy.prototype.start = function($happn, opts, callback) {
  var _this = this;

  opts = opts || { listenPort: 80 }
  opts.listenPort = opts.listenPort || 80;
  opts.tunnelComponentName = opts.tunnelComponentName || 'tunnel-service';

  $happn.log.$$TRACE('start', opts);

  var server = bouncy(function(req, res, bounce) {

    var target

    try {
      target = _this.__target($happn, req);
      bounce(target);
    }

    catch (e) {
      $happn.log.$$DEBUG('missing route for url %s', req.url, e);
      // $happn.emit('route/error', {
      //   error: e, 
      //   url: req.url,
      //   // url: require('url').parse(req.url,true),
      // });
      res.statusCode = 404;
      res.statusMessage = 'missing route for url';
      res.end();
    }

  });

  server.on('error', function(e) {
    $happn.log.error('proxy error', e);
  });


  if (opts.tunnelComponentName && !opts.tunnelEndpointName) {

    var tunnelEvents = $happn.event[opts.tunnelComponentName];

    tunnelEvents.on('tunnel/open', function(tunnel) {
      _this.createRoute($happn, tunnel);
    });

    tunnelEvents.on('tunnel/destroy', function(tunnel) {
      _this.destroyRoute($happn, tunnel);
    });

    tunnelEvents.on('tunnel/close', function(tunnel) {
      _this.destroyRoute($happn, tunnel);
    });

    // There may already be tunnels present by the time this proxy comes online,
    // get the list.

    $happn.exchange[opts.tunnelComponentName].listServers()

    .then(function(servers) {
      return Promise.map(servers, function(server) {
        return $happn.exchange[opts.tunnelComponentName].listTunnels(server)
      });
    })

    .then(function(arrayarray) {
      arrayarray.forEach(function(array) {
        array.forEach(function(tunnel) {
          // createRoute checks that the tunnel is 'open'
          _this.createRoute($happn, tunnel);
        });
      });
    });

  }

  if (opts.tunnelComponentName && opts.tunnelEndpointName) {

    var tunnelEvents = $happn.event[opts.tunnelEndpointName][opts.tunnelComponentName];

    tunnelEvents.on('tunnel/open', function(tunnel) {
      _this.createRoute($happn, tunnel);
    });

    tunnelEvents.on('tunnel/destroy', function(tunnel) {
      _this.destroyRoute($happn, tunnel);
    });

    tunnelEvents.on('tunnel/close', function(tunnel) {
      _this.destroyRoute($happn, tunnel);
    });

    // There may already be tunnels present by the time this proxy comes online,
    // get the list.

    $happn.exchange[opts.tunnelEndpointName][opts.tunnelComponentName].listServers()

    .then(function(servers) {
      return Promise.map(servers, function(server) {
        return $happn.exchange[opts.tunnelEndpointName][opts.tunnelComponentName].listTunnels(server)
      });
    })

    .then(function(arrayarray) {
      arrayarray.forEach(function(array) {
        array.forEach(function(tunnel) {
          // createRoute checks that the tunnel is 'open'
          _this.createRoute($happn, tunnel);
        });
      });
    });

  }

  server.listen(opts.listenPort, callback);

}



/**
 * Create new hostname route to tunnel entrance
 * 
 * @api public
 * @param {Tunnel} tunnel
 *
 * Provide tunnel instance as emitted in 'tunnel/open' by the tunnel-service component.
 * Creates a "route" to proxy by hostname <tunnelId>.any.domain.name into the tunnel entrance.
 *
 */

TunnelProxy.prototype.createRoute = function($happn, tunnel) {

  if (!tunnel.forwarding) {
    // tunnel is not open, no address to route to
    return;
  }

  var hostref = tunnel.id.toLowerCase();

  var route = {
    hostref: hostref,
    tunnel: {
      id: tunnel.id,
      serverId: tunnel.serverId,
    },
    forwarding: tunnel.forwarding.address + ':' + tunnel.forwarding.port
  }

  this.routes[hostref] = route;

  $happn.log.$$TRACE('route/create', route);

  $happn.emit('route/create', route);

  $happn.log.info('route hostref \'%s\' to \'%s\'', route.hostref, route.forwarding)

};


/**
 * Destroy a route
 *
 * @api public
 * @param {Tunnel} tunnel
 *
 */

TunnelProxy.prototype.destroyRoute = function($happn, tunnel) {
  
  var hostref = tunnel.id.toLowerCase();
  var route = this.routes[hostref];

  delete this.routes[hostref];

  $happn.log.$$TRACE('route/destroy', route);

  $happn.emit('route/destroy', route);

};


/**
 * List the routes in the proxy
 *
 * @api public
 * 
 */

TunnelProxy.prototype.getRoutes = function($happn) {
  return this.routes;
};


TunnelProxy.prototype.__target = function($happn, req, socket) {

  var hostref = req.headers.host.split('.')[0];
  var route = this.routes[hostref];

  if (!route) throw new Error('no route for ' + hostref);

  var target = util.format('%s://%s', req.protocol || 'http', route.forwarding);

  // directly to leaf without tunnel
  // var target = util.format('%s://%s', req.protocol || 'http', 'localhost:11011');

  return target;

}
